<!doctype html><html lang=es class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=description content=Compiladores><link href=https://cc-4.github.io/projects/proj01/ rel=canonical><meta name=author content=CC-4><meta name=lang:clipboard.copy content="Copiar al portapapeles"><meta name=lang:clipboard.copied content="Copiado al portapapeles"><meta name=lang:search.language content=es><meta name=lang:search.pipeline.stopwords content=True><meta name=lang:search.pipeline.trimmer content=True><meta name=lang:search.result.none content="No se encontraron documentos"><meta name=lang:search.result.one content="1 documento encontrado"><meta name=lang:search.result.other content="# documentos encontrados"><meta name=lang:search.tokenizer content=[\s\-]+><link rel="shortcut icon" href=../../icon.png><meta name=generator content="mkdocs-1.0.4, mkdocs-material-4.4.2"><title>Análisis Léxico - CC-4</title><link rel=stylesheet href=../../assets/stylesheets/application.30686662.css><link rel=stylesheet href=../../assets/stylesheets/application-palette.a8b3c06d.css><meta name=theme-color content><script src=../../assets/javascripts/modernizr.74668098.js></script><link href=https://fonts.gstatic.com rel=preconnect crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono&display=fallback"><style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style><link rel=stylesheet href=../../assets/fonts/material-icons.css><link rel=stylesheet href=../../css/kbd.css><link rel=stylesheet href=../../css/custom.css></head> <body dir=ltr data-md-color-primary=white data-md-color-accent=blue> <svg class=md-svg> <defs> <svg xmlns=http://www.w3.org/2000/svg width=416 height=448 viewbox="0 0 416 448" id=__github><path fill=currentColor d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg> </defs> </svg> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay data-md-component=overlay for=__drawer></label> <a href=#analisis-lexico tabindex=1 class=md-skip> Saltar a contenido </a> <header class=md-header data-md-component=header> <nav class="md-header-nav md-grid"> <div class=md-flex> <div class="md-flex__cell md-flex__cell--shrink"> <a href=https://cc-4.github.io/ title=CC-4 class="md-header-nav__button md-logo"> <img src=../../icon.png width=24 height=24> </a> </div> <div class="md-flex__cell md-flex__cell--shrink"> <label class="md-icon md-icon--menu md-header-nav__button" for=__drawer></label> </div> <div class="md-flex__cell md-flex__cell--stretch"> <div class="md-flex__ellipsis md-header-nav__title" data-md-component=title> <span class=md-header-nav__topic> CC-4 </span> <span class=md-header-nav__topic> Análisis Léxico </span> </div> </div> <div class="md-flex__cell md-flex__cell--shrink"> <label class="md-icon md-icon--search md-header-nav__button" for=__search></label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query placeholder=Búsqueda autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=query data-md-state=active> <label class="md-icon md-search__icon" for=__search></label> <button type=reset class="md-icon md-search__icon" data-md-component=reset tabindex=-1> &#xE5CD; </button> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=result> <div class=md-search-result__meta> Teclee para comenzar búsqueda </div> <ol class=md-search-result__list></ol> </div> </div> </div> </div> </div> </div> <div class="md-flex__cell md-flex__cell--shrink"> <div class=md-header-nav__source> <a href=https://github.com/CC-4/CC-4/ title="Ir al repositorio" class=md-source data-md-source=github> <div class=md-source__icon> <svg viewbox="0 0 24 24" width=24 height=24> <use xlink:href=#__github width=24 height=24></use> </svg> </div> <div class=md-source__repository> CC-4/CC-4 </div> </a> </div> </div> </div> </nav> </header> <div class=md-container> <main class=md-main role=main> <div class="md-main__inner md-grid" data-md-component=container> <div class="md-sidebar md-sidebar--primary" data-md-component=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary" data-md-level=0> <label class="md-nav__title md-nav__title--site" for=__drawer> <a href=https://cc-4.github.io/ title=CC-4 class="md-nav__button md-logo"> <img src=../../icon.png width=48 height=48> </a> CC-4 </label> <div class=md-nav__source> <a href=https://github.com/CC-4/CC-4/ title="Ir al repositorio" class=md-source data-md-source=github> <div class=md-source__icon> <svg viewbox="0 0 24 24" width=24 height=24> <use xlink:href=#__github width=24 height=24></use> </svg> </div> <div class=md-source__repository> CC-4/CC-4 </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../.. title=Inicio class=md-nav__link> Inicio </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-toggle md-nav__toggle" data-md-toggle=nav-2 type=checkbox id=nav-2> <label class=md-nav__link for=nav-2> Laboratorios </label> <nav class=md-nav data-md-component=collapsible data-md-level=1> <label class=md-nav__title for=nav-2> Laboratorios </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../labs/lab01/ title="Laboratorio 1 (COOL)" class=md-nav__link> Laboratorio 1 (COOL) </a> </li> <li class=md-nav__item> <a href=../../labs/lab02/ title="Laboratorio 2 (Lexer)" class=md-nav__link> Laboratorio 2 (Lexer) </a> </li> <li class=md-nav__item> <a href=../../labs/lab03/ title="Laboratorio 3 (RDP)" class=md-nav__link> Laboratorio 3 (RDP) </a> </li> <li class=md-nav__item> <a href=../../labs/lab04/ title="Laboratorio 4 (JCup)" class=md-nav__link> Laboratorio 4 (JCup) </a> </li> <li class=md-nav__item> <a href=../../labs/lab05/ title="Laboratorio 5 (ST)" class=md-nav__link> Laboratorio 5 (ST) </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-toggle md-nav__toggle" data-md-toggle=nav-3 type=checkbox id=nav-3 checked> <label class=md-nav__link for=nav-3> Proyectos </label> <nav class=md-nav data-md-component=collapsible data-md-level=1> <label class=md-nav__title for=nav-3> Proyectos </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../proj00/ title="Instalación de Material" class=md-nav__link> Instalación de Material </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-toggle md-nav__toggle" data-md-toggle=toc type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> Análisis Léxico </label> <a href=./ title="Análisis Léxico" class="md-nav__link md-nav__link--active"> Análisis Léxico </a> <nav class="md-nav md-nav--secondary"> <label class=md-nav__title for=__toc>Tabla de contenidos</label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#1-introduccion-a-jlex class=md-nav__link> 1. Introducción a JLex </a> </li> <li class=md-nav__item> <a href=#2-archivos-y-directorios class=md-nav__link> 2. Archivos y Directorios </a> </li> <li class=md-nav__item> <a href=#3-resultados-del-lexer class=md-nav__link> 3. Resultados del Lexer </a> <nav class=md-nav> <ul class=md-nav__list> <li class=md-nav__item> <a href=#31-manejo-de-errores class=md-nav__link> 3.1 Manejo de Errores </a> </li> <li class=md-nav__item> <a href=#32-tabla-de-strings class=md-nav__link> 3.2 Tabla de Strings </a> </li> <li class=md-nav__item> <a href=#33-strings class=md-nav__link> 3.3 Strings </a> </li> <li class=md-nav__item> <a href=#34-otras-notas class=md-nav__link> 3.4 Otras notas </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#4-notas-de-java class=md-nav__link> 4. Notas de Java </a> </li> <li class=md-nav__item> <a href=#5-probando-su-lexer class=md-nav__link> 5. Probando su Lexer </a> </li> <li class=md-nav__item> <a href=#6-autograder class=md-nav__link> 6. Autograder </a> </li> <li class=md-nav__item> <a href=#referencias class=md-nav__link> Referencias </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../proj02/ title="Análisis Sintáctico" class=md-nav__link> Análisis Sintáctico </a> </li> <li class=md-nav__item> <a href=../proj03/ title="Análisis Semántico" class=md-nav__link> Análisis Semántico </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary"> <label class=md-nav__title for=__toc>Tabla de contenidos</label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#1-introduccion-a-jlex class=md-nav__link> 1. Introducción a JLex </a> </li> <li class=md-nav__item> <a href=#2-archivos-y-directorios class=md-nav__link> 2. Archivos y Directorios </a> </li> <li class=md-nav__item> <a href=#3-resultados-del-lexer class=md-nav__link> 3. Resultados del Lexer </a> <nav class=md-nav> <ul class=md-nav__list> <li class=md-nav__item> <a href=#31-manejo-de-errores class=md-nav__link> 3.1 Manejo de Errores </a> </li> <li class=md-nav__item> <a href=#32-tabla-de-strings class=md-nav__link> 3.2 Tabla de Strings </a> </li> <li class=md-nav__item> <a href=#33-strings class=md-nav__link> 3.3 Strings </a> </li> <li class=md-nav__item> <a href=#34-otras-notas class=md-nav__link> 3.4 Otras notas </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#4-notas-de-java class=md-nav__link> 4. Notas de Java </a> </li> <li class=md-nav__item> <a href=#5-probando-su-lexer class=md-nav__link> 5. Probando su Lexer </a> </li> <li class=md-nav__item> <a href=#6-autograder class=md-nav__link> 6. Autograder </a> </li> <li class=md-nav__item> <a href=#referencias class=md-nav__link> Referencias </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content> <article class="md-content__inner md-typeset"> <a href=https://github.com/CC-4/CC-4/edit/master/docs/projects/proj01.md title="Editar esta página" class="md-icon md-content__icon">&#xE3C9;</a> <h1 id=analisis-lexico>Análisis Léxico<a class=headerlink href=#analisis-lexico title="Permanent link">&para;</a></h1> <p align=center> <img src=/img/lexer.png alt=Lexer width=200> </p> <p>Para esta asignación, van a escribir un analizador léxico, también llamado lexer, utilizando un generador de analizadores léxicos llamado <strong>JLex</strong>. Ustedes van a describir el set de tokens para COOL en un formato adecuado y JLex va a generar el código de Java para reconocer tokens en programas escritos en COOL.</p> <p>La documentación para todas las herramientas del proyecto van a estar disponibles en el material de apoyo del curso en el GES.  <h2 id=1-introduccion-a-jlex>1. Introducción a JLex<a class=headerlink href=#1-introduccion-a-jlex title="Permanent link">&para;</a></h2> <p>JLex permite implementar un analizador léxico escribiendo expresiones regulares y establecer acciones cuando alguna secuencia de caracteres hace match con alguna de estas. JLex convierte estas reglas que ustedes van a definir en un archivo llamado <strong>lexer.lex</strong> en un archivo de Java con el código que implementa un autómata finito que puede reconocer estas expresiones regulares que ustedes especificaron en el archivo <em>lexer.lex</em>. Afortunadamente, no es necesario entender o incluso mirar lo que automáticamente genera JLex. Los archivos que entiende JLex estan estructurados de la siguiente manera:</p> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class=code><div class=codehilite><pre><span></span>%{
Declaraciones
%}
Definiciones
%%
Reglas
%%
Subrutinas de Usuario
</pre></div> </td></tr></table> <p>Las secciones de <strong>Declaraciones</strong> y <strong>Subrutinas de Usuario</strong> son opcionales y les permite a ustedes escribir declaraciones y funciones de ayuda en Java. Las sección de <em>Definiciones</em> también es opcional, pero en general es bastante útil porque las definiciones les permiten a ustedes darle nombres a las expresiones regulares. Por ejemplo, la siguiente definición:</p> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre><span></span>1</pre></div></td><td class=code><div class=codehilite><pre><span></span><span class=n>DIGIT</span> <span class=o>=</span> <span class=o>[</span><span class=mi>0</span><span class=o>-</span><span class=mi>9</span><span class=o>]</span>
</pre></div> </td></tr></table> <p>Les permite definir un dígito. Aquí, <strong>DIGIT</strong> es el nombre que se le da a la expresión regular que hace match con cualquier caracter que esté entre 0 y 9. La siguiente tabla les da una vista general de expresiones regulares comunes que pueden ser especificadas en JLex.</p> <table> <thead> <tr> <th align=center>Expresión</th> <th align=center>Descripción</th> </tr> </thead> <tbody> <tr> <td align=center>x</td> <td align=center>el caracter "x"</td> </tr> <tr> <td align=center>"x"</td> <td align=center>caracter "x", incluso si x es un operador.</td> </tr> <tr> <td align=center>\x</td> <td align=center>caracter ”x”, incluso si x es un operador.</td> </tr> <tr> <td align=center>[xy]</td> <td align=center>el caracter x o y</td> </tr> <tr> <td align=center>[x-z]</td> <td align=center>los caracteres x, y, z</td> </tr> <tr> <td align=center>[^x]</td> <td align=center>cualquier caracter menos x</td> </tr> <tr> <td align=center>.</td> <td align=center>cualquier caracter menos newline</td> </tr> <tr> <td align=center>^x</td> <td align=center>caracter x al inicio de una linea</td> </tr> <tr> <td align=center><y>x</td> <td align=center>caracter x cuando JLex esta en el estado <y></td> </tr> <tr> <td align=center>x$</td> <td align=center>caracter x al final de una linea</td> </tr> <tr> <td align=center>x?</td> <td align=center>el caracter x es opcional</td> </tr> <tr> <td align=center>x*</td> <td align=center>el caracter x aparece 0 o más veces</td> </tr> <tr> <td align=center>x+</td> <td align=center>el caracter x aparece 1 o más veces</td> </tr> <tr> <td align=center>x|y</td> <td align=center>caracter x o y</td> </tr> <tr> <td align=center>(x)</td> <td align=center>caracter x</td> </tr> <tr> <td align=center>x/y</td> <td align=center>caracter x si y solo si es seguido de un caracter y</td> </tr> <tr> <td align=center>{xx}</td> <td align=center>hace referencia a la definición xx</td> </tr> <tr> <td align=center>x{m,n}</td> <td align=center>caracter x aparece entre m y n veces</td> </tr> </tbody> </table> <p>La parte más importante de su analizador léxico es la sección de reglas. Una regla en JLex especifica una acción a tomar si la entrada hace match con la expresión regular o definición al principio de la regla. La acción a tomar es especificada escribiendo código de Java regular. Por ejemplo, asumiendo que un dígito representa un token en nuestro lenguaje (noten que este no es el caso de COOL), la regla sería entonces:</p> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre><span></span>1
2
3
4</pre></div></td><td class=code><div class=codehilite><pre><span></span><span class=o>{</span><span class=n>DIGIT</span><span class=o>}</span> <span class=o>{</span>
  <span class=n>AbstractSymbol</span> <span class=n>num</span> <span class=o>=</span> <span class=n>AbstractTable</span><span class=o>.</span><span class=na>inttable</span><span class=o>.</span><span class=na>addString</span><span class=o>(</span><span class=n>yytext</span><span class=o>());</span>
  <span class=k>return</span> <span class=k>new</span> <span class=n>Symbol</span><span class=o>(</span><span class=n>TokenConstants</span><span class=o>.</span><span class=na>INT_CONST</span><span class=o>,</span> <span class=n>num</span><span class=o>);</span>
<span class=o>}</span>
</pre></div> </td></tr></table> <p>Esta regla guarda el valor del dígito en una variable global <code class=codehilite><span class=n>AbstractTable</span><span class=o>.</span><span class=na>inttable</span></code> y retorna el código apropiado para el token.</p> <div class="admonition note"> <p class=admonition-title>Nota</p> <p>Vean la sección <a href=#4-notas-de-java>4</a> para una discusión más detallada de la variable global <code class=codehilite><span class=n>AbstractTable</span><span class=o>.</span><span class=na>inttable</span></code> y vean la sección <a href=#32-tabla-de-strings>3.2</a> para una discusión sobre como <code class=codehilite><span class=n>AbstractTable</span><span class=o>.</span><span class=na>inttable</span></code> es utilizado en el código de arriba.</p> </div> <p>Un punto importante a recordar es que la entrada actual (es decir, el resultado de llamar a la función <code class=codehilite><span class=n>next_token</span><span class=o>()</span></code>) puede hacer match con múltiples reglas, JLex toma la regla que hace match con el mayor número de caracteres. Por ejemplo, si ustedes definieran las siguientes dos reglas:</p> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre><span></span>1
2</pre></div></td><td class=code><div class=codehilite><pre><span></span><span class=o>[</span><span class=mi>0</span><span class=o>-</span><span class=mi>9</span><span class=o>]+</span>      <span class=o>{</span> <span class=c1>// action 1 }</span>
<span class=o>[</span><span class=mi>0</span><span class=o>-</span><span class=mi>9</span><span class=n>a</span><span class=o>-</span><span class=n>z</span><span class=o>]+</span>   <span class=o>{</span> <span class=c1>// action 2 }</span>
</pre></div> </td></tr></table> <p>y si la secuencia de caracteres "2a" aparece en el archivo que está siendo analizado, entonces la acción 2 va a tomarse, dado que la segunda regla hace match con más caracteres que la primer regla. Si múltiples reglas hacen match con la misma cantidad de caracteres, entonces la regla que aparece primero es la que se toma.</p> <p>Cuando escriban reglas en JLex, va a ser necesario que se tomen diferentes acciones dependiendo de los tokens encontrados anteriormente. Por ejemplo, cuando esten procesando un token que representa el <em>cierre de un comentario</em>, a ustedes les va a interesar saber si un token que representa <em>abrir comentario</em> se ha encontrado anteriormente. Una forma obvia de tener registro de esto es declarar variables globales en la sección de declaraciones de JLex, que son cambiadas a verdadero cuando ciertos tokens de interés son encontrados. JLex también provee una sintáxis fácil (<em>syntatic sugar</em>) para poder lograr una funcionalidad similar utilizando declaraciones de estados como:</p> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre><span></span>1</pre></div></td><td class=code><div class=codehilite><pre><span></span><span class=o>%</span><span class=n>state</span> <span class=n>COMMENT</span>
</pre></div> </td></tr></table> <p>que puede ser cambiado a <code>true</code> escribiendo <code class=codehilite><span class=n>yybegin</span><span class=o>(</span><span class=n>COMMENT</span><span class=o>)</span></code>. Para tomar una acción si y solo si un token que representa <em>abrir comentario</em> ha sido encontrado anteriormente. Pueden agregarle un predicado a su regla utilizando la siguiente sintáxis:</p> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre><span></span>1
2
3</pre></div></td><td class=code><div class=codehilite><pre><span></span><span class=o>&lt;</span><span class=n>COMMENT</span><span class=o>&gt;</span> <span class=n>reg_exp</span> <span class=o>{</span>
  <span class=c1>// action</span>
<span class=o>}</span>
</pre></div> </td></tr></table> <p>Hay un estado default llamado <code class=codehilite><span class=n>YYINITIAL</span></code> que está activo a menos que ustedes explícitamente indiquen el inicio de un nuevo estado utilizando <code class=codehilite><span class=n>yybegin</span><span class=o>(</span><span class=n>STATE</span><span class=o>)</span></code>. Ustedes pueden encontrar útil esta sintaxis para varios aspectos de esta asignación, así como reportar errores. Nosotros les recomendamos que lean detenidamente la documentación de JLex que está en el material de apoyo del curso en el GES antes de empezar a escribir su analizador léxico.</p> <h2 id=2-archivos-y-directorios>2. Archivos y Directorios<a class=headerlink href=#2-archivos-y-directorios title="Permanent link">&para;</a></h2> <p>Para empezar, creen el directorio <strong>PA1</strong> en su carpeta que contendrá todas las demás fases como se explicó <a href=/projects/proj00/ >aquí</a> y dentro de esa carpeta en una terminal (<kbd>CTRL</kbd><kbd>+</kbd><kbd>T</kbd>) escriban lo siguiente:</p> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre><span></span>1</pre></div></td><td class=code><div class=codehilite><pre><span></span>make -f /usr/class/cc4/assignments/PA1/Makefile
</pre></div> </td></tr></table> <p>Este comando va a copiar un número de archivos en su directorio que han creado. Algunos de los archivos que van a ser copiados van a ser de solo lectura (representando a estos con archivos que realmente son enlaces simbólicos hacia otros archivos). Ustedes no deberían de editar estos archivos. De hecho, si ustedes modifican estos archivos, van a encontrar imposible terminar y completar esta asignación. Vean las instrucciones en el archivo README. Los únicos archivos que tienen permitido modificar para esta asignación son:</p> <ul class=task-list> <li class=task-list-item><label class=task-list-control><input type=checkbox disabled checked><span class=task-list-indicator></span></label> <strong>cool.lex</strong>: Este archivo contiene un esqueleto para una descripción léxica de COOL. Hay comentarios que indican donde ustedes tienen que llenar con código, pero esto no es necesariamente una guía completa. Una parte de la asignación es que ustede se aseguren que tienen un analizador léxico funcional. Exceptuando las secciones indicadas, ustedes son libres de hacer modificaciones a su esqueleto. Ustedes, de hecho, pueden generar un lexer con el archivo base pero este no hace mucho todavía. Cualquier función de ayuda que ustedes deseen escribir tiene que ser añadida directamente a este archivo en la sección apropiada (vean los comentarios en el archivo).</li> <li class=task-list-item><label class=task-list-control><input type=checkbox disabled checked><span class=task-list-indicator></span></label> <strong>test.cl</strong>: Este archivo contiene un programa de COOL ejemplo para que sea analizado. Este archivo no representa toda la especificación léxica del lenguaje COOL, pero de todas maneras es una prueba interesante. Siéntanse libres de modificar este archivo para probar su analizador léxico.</li> <li class=task-list-item><label class=task-list-control><input type=checkbox disabled checked><span class=task-list-indicator></span></label> <strong>README</strong>: Este archivo contiene instrucciones detalladas para la asignación, así como también un número de recomendaciones útiles. Realmente este archivo no lo van a modificar, pero es bueno mencionar que lo tienen que leer.</li> </ul> <div class="admonition warning"> <p class=admonition-title>Advertencia</p> <p>No modifiquen ningún archivo que no se menciona en el listado, cuando se evalue la asignación únicamente se va a probar el archivo <strong>cool.lex</strong> en un nuevo entorno.</p> </div> <h2 id=3-resultados-del-lexer>3. Resultados del Lexer<a class=headerlink href=#3-resultados-del-lexer title="Permanent link">&para;</a></h2> <p>En esta asignación, ustedes tiene que escribir reglas de JLex que hagan match con las expresiones regulares apropiadas que definan los tokens validos en COOL así como se describe en la sección número 10 y figura 1 del manual de COOL<sup id=fnref:2><a class=footnote-ref href=#fn:2>2</a></sup> y tomar las acciones apropiadas, así como retornar un token del tipo correcto, guardar el valor del lexema cuando sea necesario, o reportar un error cuando un error se encuentra. Antes de empezar con esta asignación, asegúrense de haber leído la sección 10 y la figura 1 del manual de COOL<sup id=fnref2:2><a class=footnote-ref href=#fn:2>2</a></sup>, luego estudien los diferentes tokens que están definidos en el archivo <strong>TokenConstants.java</strong>. Su implementación necesita definir reglas de JLex que hagan match con las expresiones regulares definidas para cada token descrito en el archivo <strong>TokenConstants.java</strong> y tomar la acción apropiada para cada token. Por ejemplo, si ustedes hacen match del token <code>BOOL_CONST</code>, su analizador léxico tiene que guardar el su valor ya sea que sea <code>true</code> o <code>false</code>; similarmente si hacen match con el token <code>TYPEID</code>, ustedes van a tener que guardar el nombre del tipo. Noten que no todos los tokens requieren que se guarde información adicional; por ejemplo, es suficiente que solo se devuelva el tipo de token con el que se hizo match, así como cuando se hace match con algún keyword del lenguaje como <code class=codehilite><span class=kd>class</span></code>. </p> <p>Su lexer debe de ser robusto, debería de funcionar con cualquier input. Por ejemplo, deberían de manejar errores como cuando se encuentra un caracter de <code>EOF</code> en medio de un string o comentario, así como también, como cuando se encuentra con un string que es demasiado largo. Estos son solo algunos de los errores que pueden ser encontrados, lean el manual<sup id=fnref3:2><a class=footnote-ref href=#fn:2>2</a></sup> para conocer el resto. Ustedes tienen que terminar su análisis de forma <strong>elegante</strong> si algún error fatal ocurre. Las excepciones no manejadas <strong>NO</strong> son aceptables.</p> <h3 id=31-manejo-de-errores>3.1 Manejo de Errores<a class=headerlink href=#31-manejo-de-errores title="Permanent link">&para;</a></h3> <p>Todos los errores deberían de ser pasados al parser. Su lexer no debería de imprimir <strong>NADA</strong>. Los errores se comunican al parser retornando un token de error especial llamado <code>ERROR</code> junto con el mensaje de error.</p> <div class="admonition note"> <p class=admonition-title>Nota</p> <p>Ustedes berían de ignorar el token <code>error</code> definido tambien en <strong>TokenConstants.java</strong> y no el token <code>ERROR</code> para esta asignación ya que este es utilizado únicamente en el parser.</p> </div> <p>Hay varios requerimientos para reportar errores y recuperarse de errores léxicos:</p> <ul class=task-list> <li class=task-list-item><label class=task-list-control><input type=checkbox disabled checked><span class=task-list-indicator></span></label> Cuando un caracter inválido (alguno que no puede ser algún token) se encuentra, un string que contenga solo ese caracter debería de ser retornado como el error. Tienen que resumir el análisis con el siguiente caracter.</li> <li class=task-list-item><label class=task-list-control><input type=checkbox disabled checked><span class=task-list-indicator></span></label> Si un string contiene un newline sin escape (<code>\\</code>), tienen que reportar el error como <strong>"Unterminated string constant"</strong> y resumir el análisis léxico al principio de la siguiente línea. Esto quiere decir que estamos asumiendo que el usuario simplemente olvido cerrar el string con una comilla.</li> <li class=task-list-item><label class=task-list-control><input type=checkbox disabled checked><span class=task-list-indicator></span></label> Cuando un string es demasiado largo, tienen que reportar el error <strong>"String constant too long"</strong>. Si el string contiene caracteres inválidos (por ejemplo, el caracter nulo <code>\\0</code>), tienen que reportar esto como <strong>"String contains null character"</strong>. En cualquier caso, el análisis debería de continuar hasta el final del string. El final del string es definido tanto como:<ol> <li>El principio de la siguiente línea si un newline es encontrado después de encontrar el error.</li> <li>Después de cerrar el string con <code>"</code>.</li> </ol> </li> <li class=task-list-item><label class=task-list-control><input type=checkbox disabled checked><span class=task-list-indicator></span></label> Si un comentario se queda abierto y se encuentra el caracter <code>EOF</code>, se tiene que reportar este error con <strong>"EOF in comment"</strong>. Por favor no tokenizen el contenido de los comentarios simplemente porque no se ha cerrado. Similarmente con los strings, si un <code>EOF</code> es encontrado, reporten el error como <strong>"EOF in string constant"</strong>.</li> <li class=task-list-item><label class=task-list-control><input type=checkbox disabled checked><span class=task-list-indicator></span></label> Si miran un <code>*)</code> fuera de un comentario, tienen que reportar el error como <strong>"Unmatched *)"</strong>, en vez de tokenizar esta secuencia de caracteres como <code>*</code> y como <code>)</code>.</li> <li class=task-list-item><label class=task-list-control><input type=checkbox disabled checked><span class=task-list-indicator></span></label> Recuerden de las clases teóricas que en esta fase del compilador solo agarra una clase bien limitada de errores. No tomen en cuenta ni verifiquen errores que no son errores léxicos en esta asignación. Por ejemplo, no deberían de verificar si las variables han sido declaradas anteriormente. Asegúrense de entender que errores la fase de análisis léxico puede considerar y cuales no antes de empezar.</li> </ul> <h3 id=32-tabla-de-strings>3.2 Tabla de Strings<a class=headerlink href=#32-tabla-de-strings title="Permanent link">&para;</a></h3> <p>Los programas tienden a tener muchas ocurrencias del mismo lexema. Por ejemplo, un identificar es generalmente referenciado múltiples veces dentro de un programa (de lo contrario no sería bastante útil). Para ahorrarnos un poco de espacio y tiempo, una práctica común en compiladores es guardar los lexemas en una tabla de strings. Nosotros les proveemos una implementación en Java para esto. Vean las siguientes secciones para más detalles.</p> <p>Hay un problema en decidir como manejar los identificadores especiales para las clases básicas (Object, Int, Bool, String), SELF_TYPE y self. Sin embargo, estos no son un problema hasta en las fases posteriores del compilador. El lexer debería de tratar estos identificadores especiales exactamente como otro identificador cualquiera. No verifiquen que las literales enteras caben dentro de la representación especificada en el manual de COOL<sup id=fnref4:2><a class=footnote-ref href=#fn:2>2</a></sup>. Simplemente creen un <strong>Symbol</strong> con el literal completo como el contenido del token, sin importar su tamaño.</p> <h3 id=33-strings>3.3 Strings<a class=headerlink href=#33-strings title="Permanent link">&para;</a></h3> <p>Su analizador léxico deberia de convertir los caracteres que se les antepone un caracter de escape en las constantes string a sus valores correctos. Por ejemplo, si el programador escribe los siguientes ocho caracteres:</p> <p align=center> <img src=/img/strings1.png alt="Ejemplo strings 1"> </p> <p>Su analizador léxico va a retornar un token <code>STR_CONST</code> cuyo valor semántico es estos 5 caracteres:</p> <p align=center> <img src=/img/strings2.png alt="Ejemplo strings 2"> </p> <p>Donde <code>\n</code> representa el caracter de newline de la tabla ASCII. Siguiendo la especificación de la página 15 del manual de COOL<sup id=fnref5:2><a class=footnote-ref href=#fn:2>2</a></sup>, ustedes deberían de retornar un error para un string que contenga el caracter null. Sin embargo, la secuencia de estos dos caracteres:</p> <p align=center> <img src=/img/strings_null1.png alt="Ejemplo strings 3"> </p> <p>Debería de ser convertida a un caracter:</p> <p align=center> <img src=/img/strings_null2.png alt="Ejemplo strings 4"> </p> <h3 id=34-otras-notas>3.4 Otras notas<a class=headerlink href=#34-otras-notas title="Permanent link">&para;</a></h3> <p>Su analizador léxico debería de mantener una variable llamada <strong>curr_lineno</strong>, que indica que línea del archivo de entrada está siendo analizada. Esto va a ayudar al parser a imprimir mensajes de error útiles. Ustedes deberían de ignorar el token <code>LET_STMT</code>. Es utilizado únicamente por el parser. Finalmente, noten que si la especificación léxica está incompleta (algunas entradas no tienen expresiones regulares que hagan match), entonces el lexer generado por JLex va a realizar cosas no deseables. Asegúrense de que su especificación esté completa.</p> <h2 id=4-notas-de-java>4. Notas de Java<a class=headerlink href=#4-notas-de-java title="Permanent link">&para;</a></h2> <ul class=task-list> <li class=task-list-item><label class=task-list-control><input type=checkbox disabled checked><span class=task-list-indicator></span></label> Cada llamada al lexer retorna el siguiente token y lexema de la entrada. El valor retornado por el método <code class=codehilite><span class=n>CoolLexer</span><span class=o>.</span><span class=na>next_token</span></code> es un objeto de la clase <code class=codehilite><span class=n>java_cup</span><span class=o>.</span><span class=na>runtime</span><span class=o>.</span><span class=na>Symbol</span></code>. Este objeto tiene un campo que representa el tipo del token (por ejemplo si es un entero, punto y coma, dos puntos, etc). Los códigos sintácticos o los tipos de cada token están definidos en el archivo <strong>TokenConstants.java</strong>. El componente, el valor semántico o lexema (si el token tiene), también es colocado en el objeto <code class=codehilite><span class=n>java_cup</span><span class=o>.</span><span class=na>runtime</span><span class=o>.</span><span class=na>Symbol</span></code>. La documentación para la clase <code class=codehilite><span class=n>java_cup</span><span class=o>.</span><span class=na>runtime</span><span class=o>.</span><span class=na>Symbol</span></code> está disponible en las referencias<sup id=fnref:5><a class=footnote-ref href=#fn:5>5</a></sup>. Algunos ejemplos también están en el archivo base.</li> <li class=task-list-item><label class=task-list-control><input type=checkbox disabled checked><span class=task-list-indicator></span></label> Para los identificadores de clase, de objeto, enteros y strings, el valor semántico tiene que ser de tipo <code class=codehilite><span class=n>AbstractSymbol</span></code>. Para las constantes booleanas, el valor semántico es de tipo <code class=codehilite><span class=n>java</span><span class=o>.</span><span class=na>lang</span><span class=o>.</span><span class=na>Boolean</span></code>. Excepto para los errores (vean abajo), los lexemas para otros tokens no tienen ninguna información interesante. Dado que el campo value en la clase <code class=codehilite><span class=n>java_cup</span><span class=o>.</span><span class=na>runtime</span><span class=o>.</span><span class=na>Symbol</span></code> es de tipo Object, ustedes van a necesitar castear este valor antes de utilizarlo o utilizar métodos con el valor.</li> <li class=task-list-item><label class=task-list-control><input type=checkbox disabled checked><span class=task-list-indicator></span></label> Nosotros les proveemos con una implementación para esto, que esta definida en el archivo <strong>AbstractTable.java</strong>. Por el momento, ustedes solo necesitan saber que el tipo de entrada a estas tablas es de tipo <code class=codehilite><span class=n>AbstractSymbol</span></code>.</li> <li class=task-list-item><label class=task-list-control><input type=checkbox disabled checked><span class=task-list-indicator></span></label> Cuando un error léxico occura, la rutina <code class=codehilite><span class=n>CoolLexer</span><span class=o>.</span><span class=na>next_token</span></code> debería de retornar un <code class=codehilite><span class=n>java_cup</span><span class=o>.</span><span class=na>runtime</span><span class=o>.</span><span class=na>Symbol</span></code> cuyo tipo es <code class=codehilite><span class=n>TokenConstants</span><span class=o>.</span><span class=na>ERROR</span></code> y cuyo valor semántico es el mensaje de error.</li> </ul> <h2 id=5-probando-su-lexer>5. Probando su Lexer<a class=headerlink href=#5-probando-su-lexer title="Permanent link">&para;</a></h2> <p>Hay al menos dos maneras en la que ustedes pueden probar su analizador léxico. La primer forma es generar archivos de entrada y correrlos utilizando su lexer, que imprime la línea y el lexema de cada token encontrado por su lexer. La otra forma, cuando piensen que su lexer esté funcionando correctamente, prueben correr <code>./mycoolc</code> para correr su lexer junto con otras fases del compilador (que nosotros les proveemos). Esto va a ser un compilador completo de COOL que pueden probar en cualquier programa.</p>  <h2 id=referencias>Referencias<a class=headerlink href=#referencias title="Permanent link">&para;</a></h2> <div class=footnote> <hr> <ol> <li id=fn:1> <p><a href=http://www.cs.princeton.edu/~appel/modern/java/JLex/ >JFlex Manual</a> - Manual de JLex.&#160;<a class=footnote-backref href=#fnref:1 title="Jump back to footnote 1 in the text">&#8617;</a></p> </li> <li id=fn:2> <p><a href=http://web.stanford.edu/class/cs143/materials/cool-manual.pdf>The Cool Reference Manual</a> - Manual de COOL.&#160;<a class=footnote-backref href=#fnref:2 title="Jump back to footnote 2 in the text">&#8617;</a><a class=footnote-backref href=#fnref2:2 title="Jump back to footnote 2 in the text">&#8617;</a><a class=footnote-backref href=#fnref3:2 title="Jump back to footnote 2 in the text">&#8617;</a><a class=footnote-backref href=#fnref4:2 title="Jump back to footnote 2 in the text">&#8617;</a><a class=footnote-backref href=#fnref5:2 title="Jump back to footnote 2 in the text">&#8617;</a></p> </li> <li id=fn:3> <p><a href=http://web.stanford.edu/class/cs143/materials/cool-tour.pdf>Tour of the Cool Support Code</a> - Manual del Código de Soporte de COOL.&#160;<a class=footnote-backref href=#fnref:3 title="Jump back to footnote 3 in the text">&#8617;</a></p> </li> <li id=fn:4> <p><a href=http://web.stanford.edu/class/cs143/materials/SPIM_Manual.pdf>SPIM Manual</a> - Manual de SPIM.&#160;<a class=footnote-backref href=#fnref:4 title="Jump back to footnote 4 in the text">&#8617;</a></p> </li> <li id=fn:5> <p><a href=http://web.stanford.edu/class/cs143/javadoc/java_cup/index.html>JCup Java Manual</a> - Javadoc de JCup&#160;<a class=footnote-backref href=#fnref:5 title="Jump back to footnote 5 in the text">&#8617;</a></p> </li> </ol> </div> </article> </div> </div> </main> <footer class=md-footer> <div class=md-footer-nav> <nav class="md-footer-nav__inner md-grid"> <a href=../proj00/ title="Instalación de Material" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel=prev> <div class="md-flex__cell md-flex__cell--shrink"> <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i> </div> <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title"> <span class=md-flex__ellipsis> <span class=md-footer-nav__direction> Anterior </span> Instalación de Material </span> </div> </a> <a href=../proj02/ title="Análisis Sintáctico" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel=next> <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title"> <span class=md-flex__ellipsis> <span class=md-footer-nav__direction> Siguiente </span> Análisis Sintáctico </span> </div> <div class="md-flex__cell md-flex__cell--shrink"> <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i> </div> </a> </nav> </div> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-footer-copyright> <div class=md-footer-copyright__highlight> Copyright &copy; 2015-2019 CC-4 UG </div> Last Commit: f9642c0a (andrescv) </div> <div class=md-footer-social> <link rel=stylesheet href=../../assets/fonts/font-awesome.css> <a href=https://github.com/cc-3/MachineStructures class="md-footer-social__link fa fa-github"></a> </div> </div> </div> </footer> </div> <script src=../../assets/javascripts/application.c648116f.js></script> <script src=../../assets/javascripts/lunr/lunr.stemmer.support.js></script> <script src=../../assets/javascripts/lunr/lunr.es.js></script> <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script> <script src=../../js/latex.js></script> </body> </html>