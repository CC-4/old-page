{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Compiladores \u00b6 Photo Credit: openclassroom.stanford.edu Requisitos \u00b6 Tener claros los conceptos de CC1, CC2 y CC3. Tener claros los conceptos de Inform\u00e1tica 3. Tener habilidad para programar en Java. Descripci\u00f3n \u00b6 Este es un curso introductorio al dise\u00f1o de lenguajes de programaci\u00f3n y a la implementaci\u00f3n de sus compiladores e int\u00e9rpretes. En el proceso, haremos una exploraci\u00f3n general al dise\u00f1o de lenguajes de programaci\u00f3n y su impacto en la implementaci\u00f3n de los mismos. Durante este semestre, nos enfocaremos en un lenguaje particular: Classroom Object Oriented Language ( COOL ). Objetivos \u00b6 Uno de los objetivos de este curso es explorar la estructura de los lenguajes de programaci\u00f3n y considerar alternativas a caracter\u00edsticas familiares en lenguajes de programaci\u00f3n. Estudiaremos adem\u00e1s el problema de la traducci\u00f3n de lenguajes de alto nivel a formas que pueda ejecutar la m\u00e1quina, utilizando el lenguaje COOL como lenguaje de alto nivel y RISC-V como lenguaje ensamblador. La implementaci\u00f3n de un compilador se hace por varias razones: Aprender t\u00e9cnicas que se aplican a muchas clases de problemas fuera del \u00e1mbito de un compilador, Obtener una mejor comprensi\u00f3n de las herramientas que utilizamos cuando programamos y los costos de los programas que escribimos. Para obtener experiencia construyendo y validando un problema de ingenier\u00eda sustancialmente complejo. Libro de Texto \u00b6","title":"Inicio"},{"location":"#compiladores","text":"Photo Credit: openclassroom.stanford.edu","title":"Compiladores"},{"location":"#requisitos","text":"Tener claros los conceptos de CC1, CC2 y CC3. Tener claros los conceptos de Inform\u00e1tica 3. Tener habilidad para programar en Java.","title":"Requisitos"},{"location":"#descripcion","text":"Este es un curso introductorio al dise\u00f1o de lenguajes de programaci\u00f3n y a la implementaci\u00f3n de sus compiladores e int\u00e9rpretes. En el proceso, haremos una exploraci\u00f3n general al dise\u00f1o de lenguajes de programaci\u00f3n y su impacto en la implementaci\u00f3n de los mismos. Durante este semestre, nos enfocaremos en un lenguaje particular: Classroom Object Oriented Language ( COOL ).","title":"Descripci\u00f3n"},{"location":"#objetivos","text":"Uno de los objetivos de este curso es explorar la estructura de los lenguajes de programaci\u00f3n y considerar alternativas a caracter\u00edsticas familiares en lenguajes de programaci\u00f3n. Estudiaremos adem\u00e1s el problema de la traducci\u00f3n de lenguajes de alto nivel a formas que pueda ejecutar la m\u00e1quina, utilizando el lenguaje COOL como lenguaje de alto nivel y RISC-V como lenguaje ensamblador. La implementaci\u00f3n de un compilador se hace por varias razones: Aprender t\u00e9cnicas que se aplican a muchas clases de problemas fuera del \u00e1mbito de un compilador, Obtener una mejor comprensi\u00f3n de las herramientas que utilizamos cuando programamos y los costos de los programas que escribimos. Para obtener experiencia construyendo y validando un problema de ingenier\u00eda sustancialmente complejo.","title":"Objetivos"},{"location":"#libro-de-texto","text":"","title":"Libro de Texto"},{"location":"labs/lab01/","text":"Conociendo COOL \u00b6 Para este lab, deben hacer los ejercicios que se les pide a continuaci\u00f3n, estos ejercicios son bastante b\u00e1sicos y est\u00e1n con el \u00fanico prop\u00f3sito de que ustedes sepan que se puede hacer en el lenguaje COOL. Este lab ser\u00e1 la \u00fanica vez en que sea necesario programar en COOL, pero no significa que tenga que olvidar como programar en COOL ya que para los proyectos es necesario que ustedes sean capaces de crear sus propios archivos de pruebas para probar sus implementaciones. 1. Hola Mundo \u00b6 Este ejercicio deber\u00eda de ser bastante f\u00e1cil, en un archivo llamado hello.cl , escriban un programa en COOL que imprima Hola Mundo en consola. 2. IO \u00b6 En un archivo llamado io.cl , escriban un programa en COOL que pregunte al usuario su nombre, luego su edad, luego que despliegue el nombre de la persona y cuantos a\u00f1os tendr\u00e1 al graduarse. (Sean optimistas, no le sumen tantos a\u00f1os a la edad actual). Su programa debe de funcionar de la siguiente manera: 1 2 3 4 Ingrese su nombre: Pepe Ingrese su edad: 19 Pepe tendr\u00e1 22 a\u00f1os al graduarse : ) 3. M\u00e9todos \u00b6 En un archivo llamado methods.cl , hagan un programa que le pida al usuario un n\u00famero en grados Celsius y los convierta en Farenheit. Ustedes tiene que crear un m\u00e9todo llamado toFarenheit que efect\u00fae esta conversi\u00f3n: 1 2 3 toFarenheit ( x : Int ): Int { // su codigo aqui }; Su programa debe de funcionar de la siguiente manera: 1 2 3 Ingrese grados Celsius: 32 32 \u00b0 Celsius son 89 \u00b0 Farenheit Nota COOL no tiene punto flotante, por que su implementaci\u00f3n no tiene que ser precisa, si por ejemplo el usuario mete el n\u00famero 32\u00b0 en grados Celsius, su salida debe de ser 89 a pesar de que la respuesta realmente deber\u00eda de ser 89.6\u00b0 grados Farenheit. 3. Ciclos \u00b6 En un archivo llamado loop.cl , escriban un programa que despliegue una tabla de conversion de -50 a 150 grados Celsius hacia grados Farenheit en incrementos de 10. Para este ejercico es obligatorio que utilicen un while . Su programa debe de producir el siguiente resultado: 1 4. Calculadora \u00b6 En un archivo llamado calc.cl , hagan un programa que reciba una string y despliegue el resultado de la operaci\u00f3n, las operaciones v\u00e1lidas son: + - * / Su calculadora deber\u00eda de aceptar operaciones como 3 + 4 , 125 - 70 , etc. Noten que el formato siempre es el mismo de acuerdo a la siguiente expresi\u00f3n regular: ( )*[0-9]+( )+[+-*/]( )+[0-9]+( )* . Recomendaci\u00f3n Creen un m\u00e9todo para buscar espacios. Tambi\u00e9n noten que las operaciones que van a ser ingresadas por el usuario siempre son binarias, y no algo como esto: 3 + 2 - 5 / 3 * 2 , as\u00ed que no se compliquen, aunque si implementan algo como esto ser\u00eda bastante bueno. Su programa debe de funcionar de la siguiente manera: 1 2 3 4 5 6 7 8 9 >>> 2 + 2 = 4 >>> 3 * 2 = 6 >>> 6 / 2 = 3 >>> 3 - 3 = 0 ... 6. Strings \u00b6 En un archivo llamado str.cl , escriban un programa que le pida al usuario 2 Strings y verifiquen si el segundo String est\u00e1 contenido en el primero. Su programa debe de funcionar de la siguiente manera: 1 2 3 4 5 6 7 8 9 10 Ingrese String 1 : Anita lava la tina. Ingrese String 2 : lava lava est\u00e1 contenido en Anita lava la tina. ... Ingrese String 1 : Anita lava la tina. Ingrese String 2 : shampoo shampoo no est\u00e1 contenido en Anita lava la tina. Recomendaci\u00f3n En el manual de referencia de COOL 1 hay algo que podr\u00eda ayudarnos, p\u00e1gina n\u00famero 14, en espec\u00edfico el m\u00e9todo: substr(i : Int, l : Int) . Referencias \u00b6 The Cool Reference Manual - Manual de COOL. \u21a9","title":"Laboratorio 1 (COOL)"},{"location":"labs/lab01/#conociendo-cool","text":"Para este lab, deben hacer los ejercicios que se les pide a continuaci\u00f3n, estos ejercicios son bastante b\u00e1sicos y est\u00e1n con el \u00fanico prop\u00f3sito de que ustedes sepan que se puede hacer en el lenguaje COOL. Este lab ser\u00e1 la \u00fanica vez en que sea necesario programar en COOL, pero no significa que tenga que olvidar como programar en COOL ya que para los proyectos es necesario que ustedes sean capaces de crear sus propios archivos de pruebas para probar sus implementaciones.","title":"Conociendo COOL"},{"location":"labs/lab01/#1-hola-mundo","text":"Este ejercicio deber\u00eda de ser bastante f\u00e1cil, en un archivo llamado hello.cl , escriban un programa en COOL que imprima Hola Mundo en consola.","title":"1. Hola Mundo"},{"location":"labs/lab01/#2-io","text":"En un archivo llamado io.cl , escriban un programa en COOL que pregunte al usuario su nombre, luego su edad, luego que despliegue el nombre de la persona y cuantos a\u00f1os tendr\u00e1 al graduarse. (Sean optimistas, no le sumen tantos a\u00f1os a la edad actual). Su programa debe de funcionar de la siguiente manera: 1 2 3 4 Ingrese su nombre: Pepe Ingrese su edad: 19 Pepe tendr\u00e1 22 a\u00f1os al graduarse : )","title":"2. IO"},{"location":"labs/lab01/#3-metodos","text":"En un archivo llamado methods.cl , hagan un programa que le pida al usuario un n\u00famero en grados Celsius y los convierta en Farenheit. Ustedes tiene que crear un m\u00e9todo llamado toFarenheit que efect\u00fae esta conversi\u00f3n: 1 2 3 toFarenheit ( x : Int ): Int { // su codigo aqui }; Su programa debe de funcionar de la siguiente manera: 1 2 3 Ingrese grados Celsius: 32 32 \u00b0 Celsius son 89 \u00b0 Farenheit Nota COOL no tiene punto flotante, por que su implementaci\u00f3n no tiene que ser precisa, si por ejemplo el usuario mete el n\u00famero 32\u00b0 en grados Celsius, su salida debe de ser 89 a pesar de que la respuesta realmente deber\u00eda de ser 89.6\u00b0 grados Farenheit.","title":"3. M\u00e9todos"},{"location":"labs/lab01/#3-ciclos","text":"En un archivo llamado loop.cl , escriban un programa que despliegue una tabla de conversion de -50 a 150 grados Celsius hacia grados Farenheit en incrementos de 10. Para este ejercico es obligatorio que utilicen un while . Su programa debe de producir el siguiente resultado: 1","title":"3. Ciclos"},{"location":"labs/lab01/#4-calculadora","text":"En un archivo llamado calc.cl , hagan un programa que reciba una string y despliegue el resultado de la operaci\u00f3n, las operaciones v\u00e1lidas son: + - * / Su calculadora deber\u00eda de aceptar operaciones como 3 + 4 , 125 - 70 , etc. Noten que el formato siempre es el mismo de acuerdo a la siguiente expresi\u00f3n regular: ( )*[0-9]+( )+[+-*/]( )+[0-9]+( )* . Recomendaci\u00f3n Creen un m\u00e9todo para buscar espacios. Tambi\u00e9n noten que las operaciones que van a ser ingresadas por el usuario siempre son binarias, y no algo como esto: 3 + 2 - 5 / 3 * 2 , as\u00ed que no se compliquen, aunque si implementan algo como esto ser\u00eda bastante bueno. Su programa debe de funcionar de la siguiente manera: 1 2 3 4 5 6 7 8 9 >>> 2 + 2 = 4 >>> 3 * 2 = 6 >>> 6 / 2 = 3 >>> 3 - 3 = 0 ...","title":"4. Calculadora"},{"location":"labs/lab01/#6-strings","text":"En un archivo llamado str.cl , escriban un programa que le pida al usuario 2 Strings y verifiquen si el segundo String est\u00e1 contenido en el primero. Su programa debe de funcionar de la siguiente manera: 1 2 3 4 5 6 7 8 9 10 Ingrese String 1 : Anita lava la tina. Ingrese String 2 : lava lava est\u00e1 contenido en Anita lava la tina. ... Ingrese String 1 : Anita lava la tina. Ingrese String 2 : shampoo shampoo no est\u00e1 contenido en Anita lava la tina. Recomendaci\u00f3n En el manual de referencia de COOL 1 hay algo que podr\u00eda ayudarnos, p\u00e1gina n\u00famero 14, en espec\u00edfico el m\u00e9todo: substr(i : Int, l : Int) .","title":"6. Strings"},{"location":"labs/lab01/#referencias","text":"The Cool Reference Manual - Manual de COOL. \u21a9","title":"Referencias"},{"location":"labs/lab02/","text":"CNOOL y Analizador L\u00e9xico \u00b6 En este lab implementar\u00e1n la primera fase de un compilador, un analizador l\u00e9xico, para una version sin objetos de COOL. Lo llamaremos CNOOL Classroom Not Object Oriented Language . Un analizador l\u00e9xico conforma la primer parte de un compilador. La funci\u00f3n principal de un analizador l\u00e9xico es tomar una cadena de caracteres y separarla en tokens. Cada uno de estos tokens representa un s\u00edmbolo del lenguaje de programaci\u00f3n. Con el objetivo de ayudarlos en su proyecto, a lo largo de los labs implementaremos fases del proyecto en lenguajes m\u00e1s simples, como ahorita con CNOOL dejando de lado los objetos y los comentarios y diciendo que \u00fanicamente existen tres tipos b\u00e1sicos: String, Int y Bool. La gram\u00e1tica que usar\u00e1n es una versi\u00f3n modificada de la gram\u00e1tica de COOL, la llamaremos CNOOL: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 program :: = [ feature ] + feature :: = ID ([ formal [ ,formal ] * ]) : TYPE { expr } ; formal :: = ID : TYPE expr :: = ID <- expr | ID ([ expr [ ,expr ] * ]) | ID : TYPE [ <- expr ] | {[ expr ; ] + } | expr + expr | expr - expr | expr * expr | expr / expr | ~ expr | expr < expr | expr < = expr | expr = expr | not expr | ( expr ) | ID | integer | string | true | false Para reciclar los archivos que ya tienen instalados en su m\u00e1quina, emplearemos el mismo comando que deben utilizar para el proyecto 1: 1 make -f /usr/class/cs143/assignments/PA2J/Makefile De todos los archivos que se copiar\u00e1n, \u00fanicamente deben de modificar cool.lex , y agregar las expresiones regulares necesarias para que se generen los tokens de la gram\u00e1tica. Por razones de funcionamiento, no modificaremos el archivo TokenConstants.java , que contiene todos los tokens necesarios para el proyecto. Para facilitar la implementaci\u00f3n, retiraremos los comentarios y los strings multil\u00ednea, as\u00ed como el soporte para el caracter \u2018\\n\u2019 de ellos. Tienen consultar el manual de JLex 1 para este laboratorio. Referencias \u00b6 JFlex Manual - Manual de JLex. \u21a9","title":"Laboratorio 2 (Lexer)"},{"location":"labs/lab02/#cnool-y-analizador-lexico","text":"En este lab implementar\u00e1n la primera fase de un compilador, un analizador l\u00e9xico, para una version sin objetos de COOL. Lo llamaremos CNOOL Classroom Not Object Oriented Language . Un analizador l\u00e9xico conforma la primer parte de un compilador. La funci\u00f3n principal de un analizador l\u00e9xico es tomar una cadena de caracteres y separarla en tokens. Cada uno de estos tokens representa un s\u00edmbolo del lenguaje de programaci\u00f3n. Con el objetivo de ayudarlos en su proyecto, a lo largo de los labs implementaremos fases del proyecto en lenguajes m\u00e1s simples, como ahorita con CNOOL dejando de lado los objetos y los comentarios y diciendo que \u00fanicamente existen tres tipos b\u00e1sicos: String, Int y Bool. La gram\u00e1tica que usar\u00e1n es una versi\u00f3n modificada de la gram\u00e1tica de COOL, la llamaremos CNOOL: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 program :: = [ feature ] + feature :: = ID ([ formal [ ,formal ] * ]) : TYPE { expr } ; formal :: = ID : TYPE expr :: = ID <- expr | ID ([ expr [ ,expr ] * ]) | ID : TYPE [ <- expr ] | {[ expr ; ] + } | expr + expr | expr - expr | expr * expr | expr / expr | ~ expr | expr < expr | expr < = expr | expr = expr | not expr | ( expr ) | ID | integer | string | true | false Para reciclar los archivos que ya tienen instalados en su m\u00e1quina, emplearemos el mismo comando que deben utilizar para el proyecto 1: 1 make -f /usr/class/cs143/assignments/PA2J/Makefile De todos los archivos que se copiar\u00e1n, \u00fanicamente deben de modificar cool.lex , y agregar las expresiones regulares necesarias para que se generen los tokens de la gram\u00e1tica. Por razones de funcionamiento, no modificaremos el archivo TokenConstants.java , que contiene todos los tokens necesarios para el proyecto. Para facilitar la implementaci\u00f3n, retiraremos los comentarios y los strings multil\u00ednea, as\u00ed como el soporte para el caracter \u2018\\n\u2019 de ellos. Tienen consultar el manual de JLex 1 para este laboratorio.","title":"CNOOL y Analizador L\u00e9xico"},{"location":"labs/lab02/#referencias","text":"JFlex Manual - Manual de JLex. \u21a9","title":"Referencias"},{"location":"labs/lab03/","text":"Recursive Descent Parsing (RDP) \u00b6 En este laboratorio aprenderan a implementar un recursive descent parser para una gram\u00e1tica simple. 1. Introducci\u00f3n \u00b6 En las \u00faltimas clases ustedes vieron el tema de recursive descent parsing (RDP para simplificar) , aprendieron que es un tipo de parser predictivo y que entra en la categor\u00eda de top-down parsing. Tambi\u00e9n vieron de forma general un algoritmo para implementarlo y en este laboratorio lo pondremos en pr\u00e1ctica. Como el nombre sugiere, un recursive descent parser usa funciones recursivas para implementar un parser predictivo. La idea central es que cada no-terminal en la gram\u00e1tica es representado por una de esas funciones recursivas. Cada funci\u00f3n entonces mira el siguiente token (1 token de lookahead) para poder escoger as\u00ed, una de las producciones de alg\u00fan no-terminal . De esta manera es como vamos analizando la entrada y construyendo nuestro \u00e1rbol sint\u00e1ctico (si es que la entrada tiene una sint\u00e1xis correcta, de lo contrario desplegar\u00edamos alg\u00fan error) . Recuerden que : Un analizador l\u00e9xico (lexer) convierte texto (raw-text) en un stream de tokens. Un analizador sint\u00e1ctico (parser) convierte el stream de tokens en un AST. De forma gr\u00e1fica esos 2 pasos los podemos ver asi: En este laboratorio realizaremos una calculadora con un par de operaciones e iremos un paso m\u00e1s adelante al implementar un int\u00e9rprete , es decir no crearemos un \u00e1rbol sint\u00e1ctico sino que evaluaremos online las expresiones. 2. Gram\u00e1tica \u00b6 La gram\u00e1tica con la que trabajaremos es la siguiente: 1 2 3 4 5 6 7 8 9 10 11 12 S :: = E ; E :: = E + E | E - E | E * E | E / E | E % E | E ^ E | - E | ( E ) | number # number en nuestro caso significara un double Esta gram\u00e1tica tiene un gran problema para nuestro RDP , si se recuerdan por lo visto en clase, sufre de un problema llamado left-recursion . Una de las desventajas de este tipo de parsers es que las gram\u00e1ticas con las que puede trabajar son aquellas que no son recursivas hacia la izquierda y claramente esta lo es, E ::= E + E por ejemplo. As\u00ed que lo que necesitamos hacer de primero es transformar nuestra gram\u00e1tica para que no tenga este problema, teniendo en cuenta siempre que el lenguaje que describe nuestra nueva gramatica G1 es el mismo que describe nuestra gram\u00e1tica G original, es decir: L(G1) = L(G) L(G1) = L(G) 3. Lexer \u00b6 Para el primer ejercicio de este laboratorio, ustedes van a implementar el lexer para la gram\u00e1tica de nuestra calculadora utilizando JLex . El motivo principal de esto es para que sigan ganando pr\u00e1ctica con esta herramienta, que surgan dudas y que los ayude a empezar/avanzar con el proyecto (Esperamos que la gran mayor\u00eda de personas no est\u00e9 todav\u00eda en la situaci\u00f3n de \"empezar\" el proyecto todav\u00eda...) . Para empezar clonen el siguiente repositorio de Github Classroom: 1 https://classroom.github.com/a/90lt-vz3 Dentro del repositorio van a encontrar un archivo llamado lexer.lex , en ese archivo ustedes tienen que definir el lexer para la gram\u00e1tica. Dentro de ese archivo hay en forma de comentarios algunas instrucciones para guiarlos. 3.1 Clase Token \u00b6 En el directorio de trabajo hay una clase llamada Token que nos va a servir para representar los tokens de la gram\u00e1tica y es el tipo de objeto que tenemos que devolver dentro de las acciones del lexer. Esta clase tiene 2 constructores: Token(int id, String val) Token(int id) Dentro de esta clase tambi\u00e9n est\u00e1n definidos los IDs que representan cada token y tienen que hacer uso de ellos cuando encuentren un token. En ese archivo tambi\u00e9n est\u00e1n definidos otros m\u00e9todos (Con su documentaci\u00f3n respectiva) que pueden ser \u00fatiles para la siguiente parte del laboratorio. Ejemplo: 1 2 3 // Asi se veria en la parte de acciones del archivo .lex < YYINITIAL >{ SEMI } { return new Token ( Token . SEMI ); } < YYINITIAL >{ NUMBER } { return new Token ( Token . NUMBER , yytext ()); } Cuando tengan listo m\u00e1s de algo, pueden probar lo que hicieron utilizando el siguiente comando: 1 2 3 4 5 6 make lexer ./lexer \"2 + 2;\" NUMBER : 2 + NUMBER : 2 ; 4. Parser \u00b6 Para el segundo y \u00faltimo ejercicio de este laboratorio ustedes implementar\u00e1n un RDP . Esta gram\u00e1tica es bastante simple y pr\u00e1cticamente se trata solo de expresiones aritm\u00e9ticas. Parsear expresiones de este tipo con recursive descent tiene 2 problemas: En como obtener un \u00e1rbol sint\u00e1ctico que siga la precedencia y la asociatividad de los operadores. En como hacerlo eficientemente cuando hay muchos niveles de precedencia. En clase ustedes vieron la cl\u00e1sica soluci\u00f3n para el primer problema, que a pesar de que es bastante buena y elegante, no resuelve el segundo problema. En este laboratorio les vamos a ense\u00f1ar una t\u00e9cnica llamada \"Shunting Yard Algorithm\" que es m\u00e1s eficiente y resuelve el 1ero y 2do problema, la base de este algoritmo se encuentra hasta en las calculadoras chicleras . 4.1 Clase Parser \u00b6 En el directorio de trabajo van a encontrar un archivo llamado Parser.java , en este archivo es donde ustedes tienen que implementar el parser. Pr\u00e1cticamente lo que tienen que hacer es crear una plantilla con funciones recursivas de la gramatica que modificamos (Unos pasos m\u00e1s atras) . Aqu\u00ed hay unas funciones que les pueden ser \u00fatiles como term . Ejemplo: Si nuestra gram\u00e1tica empieza de esta manera S ::= E; podriamos implementarlo de la siguiente manera. 1 2 3 4 5 6 7 boolean S () { return E () && term ( Token . SEMI ); } boolean E () { ... } 4.2 Shunting Yard Algorithm \u00b6 La idea del algoritmo shunting yard es mantener los operadores en un stack hasta que todos los operandos han sido parseados. Los operandos se mantienen en un segundo stack. El algoritmo shunting yard puede utilizarse directamente para evaluar las expresiones mientras son parseadas (como un interprete, que es lo que vamos hacer) . De manera general es convertir la entrada en notaci\u00f3n polaca inversa (infix a postfix) . La idea central del algoritmo es mantener los operadores en el stack ordenados por precedencia (la precedencia m\u00e1s baja en el fondo del stack y la m\u00e1s alta en el top del stack) , por lo menos en la ausencia de par\u00e9ntesis. Antes de meter un operador en el stack de operadores, todos los operadores que tienen mayor precedencia son sacados del stack. Sacar un operador del stack de operadores consiste en remover el operador y sus operandos del stack de operandos, evaluar, y meter el resultado en el stack de operandos. Al final de una expresi\u00f3n los operadores que quedan son sacados y evaluados con sus respectivos operandos. La siguiente tabla ilustra el proceso para un input : x * y + z. El stack se va llenando a la izquierda. push(a) : hace push de a en el stack de operandos pushOp(op) : hace push de un operador en el stack de operadores pre(op) : devuelve precedencia de un operador Para nuestra gram\u00e1tica la precedencia es la siguiente de mayor a menor: \"()\" \"- (unary)\" \"^\" \"* / %\" \"+ -\" Dentro del archivo que tienen que modificar, ustedes tienen que llenar con c\u00f3digo donde hay comentarios que dicen /*TODO CODIGO AQUI*/ . Para probar su RDP tienen que hacer lo siguiente: 1 2 3 4 5 make parser ./parser >>> 2 + 2 ; 4 .0 >>>","title":"Laboratorio 3 (RDP)"},{"location":"labs/lab03/#recursive-descent-parsing-rdp","text":"En este laboratorio aprenderan a implementar un recursive descent parser para una gram\u00e1tica simple.","title":"Recursive Descent Parsing (RDP)"},{"location":"labs/lab03/#1-introduccion","text":"En las \u00faltimas clases ustedes vieron el tema de recursive descent parsing (RDP para simplificar) , aprendieron que es un tipo de parser predictivo y que entra en la categor\u00eda de top-down parsing. Tambi\u00e9n vieron de forma general un algoritmo para implementarlo y en este laboratorio lo pondremos en pr\u00e1ctica. Como el nombre sugiere, un recursive descent parser usa funciones recursivas para implementar un parser predictivo. La idea central es que cada no-terminal en la gram\u00e1tica es representado por una de esas funciones recursivas. Cada funci\u00f3n entonces mira el siguiente token (1 token de lookahead) para poder escoger as\u00ed, una de las producciones de alg\u00fan no-terminal . De esta manera es como vamos analizando la entrada y construyendo nuestro \u00e1rbol sint\u00e1ctico (si es que la entrada tiene una sint\u00e1xis correcta, de lo contrario desplegar\u00edamos alg\u00fan error) . Recuerden que : Un analizador l\u00e9xico (lexer) convierte texto (raw-text) en un stream de tokens. Un analizador sint\u00e1ctico (parser) convierte el stream de tokens en un AST. De forma gr\u00e1fica esos 2 pasos los podemos ver asi: En este laboratorio realizaremos una calculadora con un par de operaciones e iremos un paso m\u00e1s adelante al implementar un int\u00e9rprete , es decir no crearemos un \u00e1rbol sint\u00e1ctico sino que evaluaremos online las expresiones.","title":"1. Introducci\u00f3n"},{"location":"labs/lab03/#2-gramatica","text":"La gram\u00e1tica con la que trabajaremos es la siguiente: 1 2 3 4 5 6 7 8 9 10 11 12 S :: = E ; E :: = E + E | E - E | E * E | E / E | E % E | E ^ E | - E | ( E ) | number # number en nuestro caso significara un double Esta gram\u00e1tica tiene un gran problema para nuestro RDP , si se recuerdan por lo visto en clase, sufre de un problema llamado left-recursion . Una de las desventajas de este tipo de parsers es que las gram\u00e1ticas con las que puede trabajar son aquellas que no son recursivas hacia la izquierda y claramente esta lo es, E ::= E + E por ejemplo. As\u00ed que lo que necesitamos hacer de primero es transformar nuestra gram\u00e1tica para que no tenga este problema, teniendo en cuenta siempre que el lenguaje que describe nuestra nueva gramatica G1 es el mismo que describe nuestra gram\u00e1tica G original, es decir: L(G1) = L(G) L(G1) = L(G)","title":"2. Gram\u00e1tica"},{"location":"labs/lab03/#3-lexer","text":"Para el primer ejercicio de este laboratorio, ustedes van a implementar el lexer para la gram\u00e1tica de nuestra calculadora utilizando JLex . El motivo principal de esto es para que sigan ganando pr\u00e1ctica con esta herramienta, que surgan dudas y que los ayude a empezar/avanzar con el proyecto (Esperamos que la gran mayor\u00eda de personas no est\u00e9 todav\u00eda en la situaci\u00f3n de \"empezar\" el proyecto todav\u00eda...) . Para empezar clonen el siguiente repositorio de Github Classroom: 1 https://classroom.github.com/a/90lt-vz3 Dentro del repositorio van a encontrar un archivo llamado lexer.lex , en ese archivo ustedes tienen que definir el lexer para la gram\u00e1tica. Dentro de ese archivo hay en forma de comentarios algunas instrucciones para guiarlos.","title":"3. Lexer"},{"location":"labs/lab03/#31-clase-token","text":"En el directorio de trabajo hay una clase llamada Token que nos va a servir para representar los tokens de la gram\u00e1tica y es el tipo de objeto que tenemos que devolver dentro de las acciones del lexer. Esta clase tiene 2 constructores: Token(int id, String val) Token(int id) Dentro de esta clase tambi\u00e9n est\u00e1n definidos los IDs que representan cada token y tienen que hacer uso de ellos cuando encuentren un token. En ese archivo tambi\u00e9n est\u00e1n definidos otros m\u00e9todos (Con su documentaci\u00f3n respectiva) que pueden ser \u00fatiles para la siguiente parte del laboratorio. Ejemplo: 1 2 3 // Asi se veria en la parte de acciones del archivo .lex < YYINITIAL >{ SEMI } { return new Token ( Token . SEMI ); } < YYINITIAL >{ NUMBER } { return new Token ( Token . NUMBER , yytext ()); } Cuando tengan listo m\u00e1s de algo, pueden probar lo que hicieron utilizando el siguiente comando: 1 2 3 4 5 6 make lexer ./lexer \"2 + 2;\" NUMBER : 2 + NUMBER : 2 ;","title":"3.1 Clase Token"},{"location":"labs/lab03/#4-parser","text":"Para el segundo y \u00faltimo ejercicio de este laboratorio ustedes implementar\u00e1n un RDP . Esta gram\u00e1tica es bastante simple y pr\u00e1cticamente se trata solo de expresiones aritm\u00e9ticas. Parsear expresiones de este tipo con recursive descent tiene 2 problemas: En como obtener un \u00e1rbol sint\u00e1ctico que siga la precedencia y la asociatividad de los operadores. En como hacerlo eficientemente cuando hay muchos niveles de precedencia. En clase ustedes vieron la cl\u00e1sica soluci\u00f3n para el primer problema, que a pesar de que es bastante buena y elegante, no resuelve el segundo problema. En este laboratorio les vamos a ense\u00f1ar una t\u00e9cnica llamada \"Shunting Yard Algorithm\" que es m\u00e1s eficiente y resuelve el 1ero y 2do problema, la base de este algoritmo se encuentra hasta en las calculadoras chicleras .","title":"4. Parser"},{"location":"labs/lab03/#41-clase-parser","text":"En el directorio de trabajo van a encontrar un archivo llamado Parser.java , en este archivo es donde ustedes tienen que implementar el parser. Pr\u00e1cticamente lo que tienen que hacer es crear una plantilla con funciones recursivas de la gramatica que modificamos (Unos pasos m\u00e1s atras) . Aqu\u00ed hay unas funciones que les pueden ser \u00fatiles como term . Ejemplo: Si nuestra gram\u00e1tica empieza de esta manera S ::= E; podriamos implementarlo de la siguiente manera. 1 2 3 4 5 6 7 boolean S () { return E () && term ( Token . SEMI ); } boolean E () { ... }","title":"4.1 Clase Parser"},{"location":"labs/lab03/#42-shunting-yard-algorithm","text":"La idea del algoritmo shunting yard es mantener los operadores en un stack hasta que todos los operandos han sido parseados. Los operandos se mantienen en un segundo stack. El algoritmo shunting yard puede utilizarse directamente para evaluar las expresiones mientras son parseadas (como un interprete, que es lo que vamos hacer) . De manera general es convertir la entrada en notaci\u00f3n polaca inversa (infix a postfix) . La idea central del algoritmo es mantener los operadores en el stack ordenados por precedencia (la precedencia m\u00e1s baja en el fondo del stack y la m\u00e1s alta en el top del stack) , por lo menos en la ausencia de par\u00e9ntesis. Antes de meter un operador en el stack de operadores, todos los operadores que tienen mayor precedencia son sacados del stack. Sacar un operador del stack de operadores consiste en remover el operador y sus operandos del stack de operandos, evaluar, y meter el resultado en el stack de operandos. Al final de una expresi\u00f3n los operadores que quedan son sacados y evaluados con sus respectivos operandos. La siguiente tabla ilustra el proceso para un input : x * y + z. El stack se va llenando a la izquierda. push(a) : hace push de a en el stack de operandos pushOp(op) : hace push de un operador en el stack de operadores pre(op) : devuelve precedencia de un operador Para nuestra gram\u00e1tica la precedencia es la siguiente de mayor a menor: \"()\" \"- (unary)\" \"^\" \"* / %\" \"+ -\" Dentro del archivo que tienen que modificar, ustedes tienen que llenar con c\u00f3digo donde hay comentarios que dicen /*TODO CODIGO AQUI*/ . Para probar su RDP tienen que hacer lo siguiente: 1 2 3 4 5 make parser ./parser >>> 2 + 2 ; 4 .0 >>>","title":"4.2 Shunting Yard Algorithm"},{"location":"labs/lab04/","text":"Conociendo Cup \u00b6 En este laboratorio aprender\u00e1n a utilizar JCup, el analizador sint\u00e1ctico que utilizar\u00e1n en la fase 2 de su proyecto. 1. Introducci\u00f3n \u00b6 Descarguen todos los archivos del siguiente repositorio: 1 https://classroom.github.com/a/R9VITTN8 Ahora que han terminado la fase 1 de su proyecto, saben utilizar JLex para el an\u00e1lisis l\u00e9xico de una cadena de caracteres. Como han visto en clase, el an\u00e1lisis sint\u00e1ctico se basa en gram\u00e1ticas, y tiene algoritmos muy bien definidos para poder ser implementado. Para prepararlos para la fase 2, utilizaremos una herramienta llamada JCup, que funciona para analizar la sint\u00e1xis de un texto dado. Al igual que JLex, JCup cuenta con una secci\u00f3n en donde se colocan las funciones que posteriormente se copiar\u00e1n en la clase generada, en este laboratorio no utilizaremos esta funcionalidad, pero les ser\u00e1 \u00fatil para su proyecto. Luego existe una lista de s\u00edmbolos terminales, como los par\u00e9ntesis, los d\u00edgitos, etc., seguido de una lista de s\u00edmbolos no terminales. Tanto los s\u00edmbolos terminales como los no terminales pueden tener un tipo definido: 1 2 3 terminal PLUS , MINUS , MULT ; terminal Integer INTEGER ; terminal Float FLOAT ; Luego pueden especificar una precedencia. Por ejemplo, una multiplicaci\u00f3n se debe hacer antes que una suma. Para este tipo de precedencia deben emplear \"precedence left\", como en el siguiente ejemplo: 1 2 precedence left PLUS , MINUS ; precedence left TIMES ; Seguido de eso, van todas las reglas de producci\u00f3n. Siguiendo la siguiente sint\u00e1xis, en donde RESULT es la derivaci\u00f3n usando bottom-up parsing. 1 parent_expr ::= LPAREN expr : e RPAREN {: RESULT = e ; :}; 2. Lexer \u00b6 La gram\u00e1tica con la que trabajaremos es la siguiente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 S :: = S expr_part | expr_part ; expr_part :: = expr ; expr :: = exprI | exprF exprI :: = I + I | I - I | I * I | I / I | I % I | ( I ) exprF :: = I + F | F + I | F + F | I - F | F - I | F - F | I * F | F * I | F * F | I / F | F / I | F / F | I ^ F | F ^ I | F ^ F | sin I | sin F | cos I | cos F | tan I | tan F | ( F ) # donde I es un entero y F es un float. Para la primer parte deben completar el archivo calculator.lex generando los tokens necesarios para una calculadora con operaciones b\u00e1sicas y que maneje tanto floats como enteros. Noten que las funciones trigonom\u00e9tricas no son case sensitive, por lo que \"sin\" y \"sIN\" son aceptadas de igual manera. Esta es la lista de tokens que debe tener: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 SEMI PLUS MINUS TIMES DIVI LPAREN RPAREN POW REM SIN COS TAN INTEGER FLOAT Si analizan la gram\u00e1tica, pueden ver que una expresi\u00f3n puede ser una expresi\u00f3n entera, o una expresi\u00f3n de punto flotante. M\u00e1s adelante ver\u00e1n que esta gram\u00e1tica se puede simplificar dejando la distinci\u00f3n entre enteros y floats al analizador sem\u00e1ntico. 3. Parser \u00b6 Para la segunda parte, ustedes deben completar el archivo calculator.cup , agregando las reglas de derivaci\u00f3n bottom-up. Pueden agregar tantos s\u00edmbolos no terminales como quieran, pero no pueden modificar ninguno de los s\u00edmbolos terminales. Una vez agregadas todas las reglas de derivaci\u00f3n, pueden compilar su archivo de la siguiente manera: 1 sh make.sh y para correrlo: 1 sh calculator.sh As\u00ed se deber\u00e1 de ver al probarlo: 1 2 3 4 2 + 2 ; = 4 ; 4 * cos ( 0 .41e1 ^ 2 ) ; = -1.807120 ; Nota Noten que el argumento de las funciones trigonom\u00e9tricas est\u00e1 en radianes. Una vez terminado, tienen que realizar un commit de los archivos .cup y .lex y subir al GES el link de su repositorio. Referencias \u00b6 JCup Manual - Manual de JCup \u21a9 JCup Java Manual - Javadoc de JCup \u21a9","title":"Laboratorio 4 (JCup)"},{"location":"labs/lab04/#conociendo-cup","text":"En este laboratorio aprender\u00e1n a utilizar JCup, el analizador sint\u00e1ctico que utilizar\u00e1n en la fase 2 de su proyecto.","title":"Conociendo Cup"},{"location":"labs/lab04/#1-introduccion","text":"Descarguen todos los archivos del siguiente repositorio: 1 https://classroom.github.com/a/R9VITTN8 Ahora que han terminado la fase 1 de su proyecto, saben utilizar JLex para el an\u00e1lisis l\u00e9xico de una cadena de caracteres. Como han visto en clase, el an\u00e1lisis sint\u00e1ctico se basa en gram\u00e1ticas, y tiene algoritmos muy bien definidos para poder ser implementado. Para prepararlos para la fase 2, utilizaremos una herramienta llamada JCup, que funciona para analizar la sint\u00e1xis de un texto dado. Al igual que JLex, JCup cuenta con una secci\u00f3n en donde se colocan las funciones que posteriormente se copiar\u00e1n en la clase generada, en este laboratorio no utilizaremos esta funcionalidad, pero les ser\u00e1 \u00fatil para su proyecto. Luego existe una lista de s\u00edmbolos terminales, como los par\u00e9ntesis, los d\u00edgitos, etc., seguido de una lista de s\u00edmbolos no terminales. Tanto los s\u00edmbolos terminales como los no terminales pueden tener un tipo definido: 1 2 3 terminal PLUS , MINUS , MULT ; terminal Integer INTEGER ; terminal Float FLOAT ; Luego pueden especificar una precedencia. Por ejemplo, una multiplicaci\u00f3n se debe hacer antes que una suma. Para este tipo de precedencia deben emplear \"precedence left\", como en el siguiente ejemplo: 1 2 precedence left PLUS , MINUS ; precedence left TIMES ; Seguido de eso, van todas las reglas de producci\u00f3n. Siguiendo la siguiente sint\u00e1xis, en donde RESULT es la derivaci\u00f3n usando bottom-up parsing. 1 parent_expr ::= LPAREN expr : e RPAREN {: RESULT = e ; :};","title":"1. Introducci\u00f3n"},{"location":"labs/lab04/#2-lexer","text":"La gram\u00e1tica con la que trabajaremos es la siguiente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 S :: = S expr_part | expr_part ; expr_part :: = expr ; expr :: = exprI | exprF exprI :: = I + I | I - I | I * I | I / I | I % I | ( I ) exprF :: = I + F | F + I | F + F | I - F | F - I | F - F | I * F | F * I | F * F | I / F | F / I | F / F | I ^ F | F ^ I | F ^ F | sin I | sin F | cos I | cos F | tan I | tan F | ( F ) # donde I es un entero y F es un float. Para la primer parte deben completar el archivo calculator.lex generando los tokens necesarios para una calculadora con operaciones b\u00e1sicas y que maneje tanto floats como enteros. Noten que las funciones trigonom\u00e9tricas no son case sensitive, por lo que \"sin\" y \"sIN\" son aceptadas de igual manera. Esta es la lista de tokens que debe tener: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 SEMI PLUS MINUS TIMES DIVI LPAREN RPAREN POW REM SIN COS TAN INTEGER FLOAT Si analizan la gram\u00e1tica, pueden ver que una expresi\u00f3n puede ser una expresi\u00f3n entera, o una expresi\u00f3n de punto flotante. M\u00e1s adelante ver\u00e1n que esta gram\u00e1tica se puede simplificar dejando la distinci\u00f3n entre enteros y floats al analizador sem\u00e1ntico.","title":"2. Lexer"},{"location":"labs/lab04/#3-parser","text":"Para la segunda parte, ustedes deben completar el archivo calculator.cup , agregando las reglas de derivaci\u00f3n bottom-up. Pueden agregar tantos s\u00edmbolos no terminales como quieran, pero no pueden modificar ninguno de los s\u00edmbolos terminales. Una vez agregadas todas las reglas de derivaci\u00f3n, pueden compilar su archivo de la siguiente manera: 1 sh make.sh y para correrlo: 1 sh calculator.sh As\u00ed se deber\u00e1 de ver al probarlo: 1 2 3 4 2 + 2 ; = 4 ; 4 * cos ( 0 .41e1 ^ 2 ) ; = -1.807120 ; Nota Noten que el argumento de las funciones trigonom\u00e9tricas est\u00e1 en radianes. Una vez terminado, tienen que realizar un commit de los archivos .cup y .lex y subir al GES el link de su repositorio.","title":"3. Parser"},{"location":"labs/lab04/#referencias","text":"JCup Manual - Manual de JCup \u21a9 JCup Java Manual - Javadoc de JCup \u21a9","title":"Referencias"},{"location":"labs/lab05/","text":"Tabla de S\u00edmbolos \u00b6 En este laboratorio aprenderan a implementar una tabla de simbolos como la que usaran en la fase 3 del proyecto. 1. Introducci\u00f3n \u00b6 Han terminado las primeras 2 fases de su proyecto, y ahora es donde empieza la verdadera batalla contra el dragon. En la fase 3 se encargar\u00e1n de hacer el an\u00e1lisis sem\u00e1ntico del compilador, es decir, en pocas palabras, deben asignar un tipo a cada nodo del \u00e1rbol generado en la fase 2, y as\u00ed terminar de capturar cualquier error o inconsistencia en el c\u00f3digo o programa a compilar. Para realizar esta fase, ustedes deben implementar una tabla de s\u00edmbolos en donde guardar\u00e1n todas las variables declaradas para validar su existencia en base a su scope, y poder asignar un tipo a cada una. Para iniciar, ejecuten el comando para generar los archivos necesarios: 1 $~ make -f /usr/class/cs143/assignments/PA4J/Makefile 2. Tabla de Simbolos \u00b6 Estos son los archivos necesarios para implementar la fase 3 del proyecto, pero por ahora nos enfocaremos \u00fanicamente en SymtabExample.java . Ve\u00e1n que este archivo contiene un ejemplo de como funciona la tabla de s\u00edmbolos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // se crea la tabla de sibolos. SymbolTable map = new SymbolTable (); // se crea un nuevo AbstractSymbol AbstractSymbol fred = AbstractTable . stringtable . addString ( \"Fred\" ); // se agrega un nuevo scope a la tabla. Notese que al crear la tabla, esta no contiene ningun scope map . enterScope (); // se agrega el simbolo a la tabla junto con un valor map . addId ( fred , new Integer ( 22 )); // busca y devuelve el valor asociado al simbolo en el scope actual, si no lo encuentra, devuelve null map . probe ( fred ) // busca y devuelve el valor asociado al simbolo en todos los scopes, si no lo encuentra, devuelve null map . lookup ( fred ) // elimina el ultimo scope creado. map . exitScope (); La tabla de simbolos ( SymbolTable.java ), en su implementacion, utiliza un stack para los scopes, y adicional al ejemplo que tienen en el archivo, estos son los metodos que contiene la clase: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // un constructor sin parametros que inicializa la tabla public SymbolTable () // agrega un nuevo scope a la tabla, en forma de una HashTable public void enterScope () // elimina el ultimo scope agregado public void exitScope () // agrega una entrada a la tabla en el scope mas reciente public void addId ( AbstractSymbol id , Object info ) // busca y devuelve el valor del simbolo. Busca unicamente en el scope mas reciente public Object probe ( AbstractSymbol sym ) // busca en todos los scopes de la tabla. Devuelve el valor del simbolo mas reciente que encontro public Object lookup ( AbstractSymbol sym ) // devuelve un String que representa la tabla public String toString () Vean que las entradas de la tabla de s\u00edmbolos son pares (Key,Value), donde el valor es de tipo Object . En este laboratorio, para simplificar la calificaci\u00f3n, ingresaremos \u00fanicamente valores de tipo String . Ahora que se han familiarizado un poco con la tabla de s\u00edmbolos, es hora de modificar el archivo SymtabExample.java . Agreguen a este un men\u00fa en el que se puedan realizar las siguientes operaciones: Agregar S\u00edmbolo Agregar Scope Borrar Scope Buscar en el scope actual (devolver el valor almacenado con el s\u00edmbolo) Buscar en cualquier scope (devolver el valor almacenado con el s\u00edmbolo) Comparar el valor de 2 simbolos diferentes Imprimir tabla de s\u00edmbolos Salir Para compilar su programa deben de hacer lo siguiente: 1 make symtab-example Para ejecutarlo: 1 ./symtab-example Una vez terminado todo, envien al GES un archivo .zip conteniendo \u00fanicamente el archivo SymtabExample.java","title":"Laboratorio 5 (ST)"},{"location":"labs/lab05/#tabla-de-simbolos","text":"En este laboratorio aprenderan a implementar una tabla de simbolos como la que usaran en la fase 3 del proyecto.","title":"Tabla de S\u00edmbolos"},{"location":"labs/lab05/#1-introduccion","text":"Han terminado las primeras 2 fases de su proyecto, y ahora es donde empieza la verdadera batalla contra el dragon. En la fase 3 se encargar\u00e1n de hacer el an\u00e1lisis sem\u00e1ntico del compilador, es decir, en pocas palabras, deben asignar un tipo a cada nodo del \u00e1rbol generado en la fase 2, y as\u00ed terminar de capturar cualquier error o inconsistencia en el c\u00f3digo o programa a compilar. Para realizar esta fase, ustedes deben implementar una tabla de s\u00edmbolos en donde guardar\u00e1n todas las variables declaradas para validar su existencia en base a su scope, y poder asignar un tipo a cada una. Para iniciar, ejecuten el comando para generar los archivos necesarios: 1 $~ make -f /usr/class/cs143/assignments/PA4J/Makefile","title":"1. Introducci\u00f3n"},{"location":"labs/lab05/#2-tabla-de-simbolos","text":"Estos son los archivos necesarios para implementar la fase 3 del proyecto, pero por ahora nos enfocaremos \u00fanicamente en SymtabExample.java . Ve\u00e1n que este archivo contiene un ejemplo de como funciona la tabla de s\u00edmbolos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // se crea la tabla de sibolos. SymbolTable map = new SymbolTable (); // se crea un nuevo AbstractSymbol AbstractSymbol fred = AbstractTable . stringtable . addString ( \"Fred\" ); // se agrega un nuevo scope a la tabla. Notese que al crear la tabla, esta no contiene ningun scope map . enterScope (); // se agrega el simbolo a la tabla junto con un valor map . addId ( fred , new Integer ( 22 )); // busca y devuelve el valor asociado al simbolo en el scope actual, si no lo encuentra, devuelve null map . probe ( fred ) // busca y devuelve el valor asociado al simbolo en todos los scopes, si no lo encuentra, devuelve null map . lookup ( fred ) // elimina el ultimo scope creado. map . exitScope (); La tabla de simbolos ( SymbolTable.java ), en su implementacion, utiliza un stack para los scopes, y adicional al ejemplo que tienen en el archivo, estos son los metodos que contiene la clase: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // un constructor sin parametros que inicializa la tabla public SymbolTable () // agrega un nuevo scope a la tabla, en forma de una HashTable public void enterScope () // elimina el ultimo scope agregado public void exitScope () // agrega una entrada a la tabla en el scope mas reciente public void addId ( AbstractSymbol id , Object info ) // busca y devuelve el valor del simbolo. Busca unicamente en el scope mas reciente public Object probe ( AbstractSymbol sym ) // busca en todos los scopes de la tabla. Devuelve el valor del simbolo mas reciente que encontro public Object lookup ( AbstractSymbol sym ) // devuelve un String que representa la tabla public String toString () Vean que las entradas de la tabla de s\u00edmbolos son pares (Key,Value), donde el valor es de tipo Object . En este laboratorio, para simplificar la calificaci\u00f3n, ingresaremos \u00fanicamente valores de tipo String . Ahora que se han familiarizado un poco con la tabla de s\u00edmbolos, es hora de modificar el archivo SymtabExample.java . Agreguen a este un men\u00fa en el que se puedan realizar las siguientes operaciones: Agregar S\u00edmbolo Agregar Scope Borrar Scope Buscar en el scope actual (devolver el valor almacenado con el s\u00edmbolo) Buscar en cualquier scope (devolver el valor almacenado con el s\u00edmbolo) Comparar el valor de 2 simbolos diferentes Imprimir tabla de s\u00edmbolos Salir Para compilar su programa deben de hacer lo siguiente: 1 make symtab-example Para ejecutarlo: 1 ./symtab-example Una vez terminado todo, envien al GES un archivo .zip conteniendo \u00fanicamente el archivo SymtabExample.java","title":"2. Tabla de Simbolos"},{"location":"projects/proj00/","text":"Instalaci\u00f3n del Material \u00b6 Para poder realizar las fases del proyecto del compilador se requiere que utilicen una distribucion de Linux por lo que se les proporcionar\u00e1n dos opciones: Descargar una m\u00e1quina virtual con el contenido necesario ( opci\u00f3n recomendada ). Instalar una distribuci\u00f3n de Linux y descargar e instalar el material en su computadora. El material que se incluye es el c\u00f3digo base que les serivir\u00e1 para poder comenzar las fases del proyecto y una versi\u00f3n de SPIM compatible con los programas de MIPS que genera COOL, un compilador de COOL llamado coolc con el cual pueden comenzar a escribir programas en COOL y compilarlos. Luego de tener instalado el material deben de crear una carpeta en donde guardar\u00e1n su c\u00f3digo y que contendr\u00e1 cada una de las fases del proyecto. Esta carpeta se puede llamar como ustedes quieram la carpeta debe contener las siguientes carpetas: PA1 ( An\u00e1lisis L\u00e9xico ) PA2 ( An\u00e1lisis Sint\u00e1ctico ) PA3 ( An\u00e1lisis Sem\u00e1ntico ) PA4 ( Generaci\u00f3n de C\u00f3digo ) Cada una de estas carpetas corresponder\u00e1 a una fase del proyecto. Utilizaremos scripts automatizados para calificar por lo que si usted no respeta este convenio de nombres de carpetas, puede tener problemas con su nota . Despu\u00e9s de haber realizado lo anterior, como se les mencion\u00f3 en clase, el uso de GIT ser\u00e1 obligatorio . Por lo tanto, dentro de la carpeta inicial (la cual nombraron como ustedes deseaban), deben iniciar un repositorio de GIT. 1 git init Opci\u00f3n 1: M\u00e1quina Virtual \u00b6 La m\u00e1quina virtual la pueden descargar desde cualquiera de los siguientes enlaces (ocupa 3.73Gb): Google Drive Mega Es una m\u00e1quina virtual de Ubuntu 16.04 LTS para VMWare Workstation 12, despu\u00e9s de descargar el archivo CC4.zip debe descomprimirlo y abrir el archivo .ovf con el cual le deber\u00e1 salir una ventana para agregar la m\u00e1quina virtual a su VMWare. Nota La contrase\u00f1a de la m\u00e1quina virtual es cool . Opci\u00f3n 2: Instalar el Material \u00b6 Para esta opci\u00f3n se asume que tienen ya una m\u00e1quina con una distribuci\u00f3n de Linux instalada, entonces en una terminal (pueden abrir una haciendo CTRL + T ) tiene que escribir hacer lo siguiente: 1 2 3 wget https://cc-4.github.io/assets/install_cc4.sh chmod +x install_cc4.sh . ./install_cc4.sh esto descargar\u00e1 Java 8 (Oracle), Jlex, CUP, git y el c\u00f3digo necesario para el proyecto. Nota Si tienen problemas para usar spim y les sale un error que no se encuentra el archivo prueben ejecutar esta linea: 1 sudo apt install lib32z1 lib32ncurses5","title":"Instalaci\u00f3n de Material"},{"location":"projects/proj00/#instalacion-del-material","text":"Para poder realizar las fases del proyecto del compilador se requiere que utilicen una distribucion de Linux por lo que se les proporcionar\u00e1n dos opciones: Descargar una m\u00e1quina virtual con el contenido necesario ( opci\u00f3n recomendada ). Instalar una distribuci\u00f3n de Linux y descargar e instalar el material en su computadora. El material que se incluye es el c\u00f3digo base que les serivir\u00e1 para poder comenzar las fases del proyecto y una versi\u00f3n de SPIM compatible con los programas de MIPS que genera COOL, un compilador de COOL llamado coolc con el cual pueden comenzar a escribir programas en COOL y compilarlos. Luego de tener instalado el material deben de crear una carpeta en donde guardar\u00e1n su c\u00f3digo y que contendr\u00e1 cada una de las fases del proyecto. Esta carpeta se puede llamar como ustedes quieram la carpeta debe contener las siguientes carpetas: PA1 ( An\u00e1lisis L\u00e9xico ) PA2 ( An\u00e1lisis Sint\u00e1ctico ) PA3 ( An\u00e1lisis Sem\u00e1ntico ) PA4 ( Generaci\u00f3n de C\u00f3digo ) Cada una de estas carpetas corresponder\u00e1 a una fase del proyecto. Utilizaremos scripts automatizados para calificar por lo que si usted no respeta este convenio de nombres de carpetas, puede tener problemas con su nota . Despu\u00e9s de haber realizado lo anterior, como se les mencion\u00f3 en clase, el uso de GIT ser\u00e1 obligatorio . Por lo tanto, dentro de la carpeta inicial (la cual nombraron como ustedes deseaban), deben iniciar un repositorio de GIT. 1 git init","title":"Instalaci\u00f3n del Material"},{"location":"projects/proj00/#opcion-1-maquina-virtual","text":"La m\u00e1quina virtual la pueden descargar desde cualquiera de los siguientes enlaces (ocupa 3.73Gb): Google Drive Mega Es una m\u00e1quina virtual de Ubuntu 16.04 LTS para VMWare Workstation 12, despu\u00e9s de descargar el archivo CC4.zip debe descomprimirlo y abrir el archivo .ovf con el cual le deber\u00e1 salir una ventana para agregar la m\u00e1quina virtual a su VMWare. Nota La contrase\u00f1a de la m\u00e1quina virtual es cool .","title":"Opci\u00f3n 1: M\u00e1quina Virtual"},{"location":"projects/proj00/#opcion-2-instalar-el-material","text":"Para esta opci\u00f3n se asume que tienen ya una m\u00e1quina con una distribuci\u00f3n de Linux instalada, entonces en una terminal (pueden abrir una haciendo CTRL + T ) tiene que escribir hacer lo siguiente: 1 2 3 wget https://cc-4.github.io/assets/install_cc4.sh chmod +x install_cc4.sh . ./install_cc4.sh esto descargar\u00e1 Java 8 (Oracle), Jlex, CUP, git y el c\u00f3digo necesario para el proyecto. Nota Si tienen problemas para usar spim y les sale un error que no se encuentra el archivo prueben ejecutar esta linea: 1 sudo apt install lib32z1 lib32ncurses5","title":"Opci\u00f3n 2: Instalar el Material"},{"location":"projects/proj01/","text":"An\u00e1lisis L\u00e9xico \u00b6 Para esta asignaci\u00f3n, van a escribir un analizador l\u00e9xico, tambi\u00e9n llamado lexer, utilizando un generador de analizadores l\u00e9xicos llamado JLex . Ustedes van a describir el set de tokens para COOL en un formato adecuado y JLex va a generar el c\u00f3digo de Java para reconocer tokens en programas escritos en COOL. La documentaci\u00f3n para todas las herramientas del proyecto van a estar disponibles en el material de apoyo del curso en el GES. Esto incluye los manuales de JLex 1 (utilizado para esta asignaci\u00f3n), la documentaci\u00f3n para JCup (utilizado en la siguiente asignaci\u00f3n), as\u00ed como tambi\u00e9n el manual para el simulador SPIM 4 . Ustedes deber\u00edan de trabajar en parejas o individualmente para este proyecto. 1. Introducci\u00f3n a JLex \u00b6 JLex permite implementar un analizador l\u00e9xico escribiendo expresiones regulares y establecer acciones cuando alguna secuencia de caracteres hace match con alguna de estas. JLex convierte estas reglas que ustedes van a definir en un archivo llamado lexer.lex en un archivo de Java con el c\u00f3digo que implementa un aut\u00f3mata finito que puede reconocer estas expresiones regulares que ustedes especificaron en el archivo lexer.lex . Afortunadamente, no es necesario entender o incluso mirar lo que autom\u00e1ticamente genera JLex. Los archivos que entiende JLex estan estructurados de la siguiente manera: 1 2 3 4 5 6 7 8 %{ Declaraciones %} Definiciones %% Reglas %% Subrutinas de Usuario Las secciones de Declaraciones y Subrutinas de Usuario son opcionales y les permite a ustedes escribir declaraciones y funciones de ayuda en Java. Las secci\u00f3n de Definiciones tambi\u00e9n es opcional, pero en general es bastante \u00fatil porque las definiciones les permiten a ustedes darle nombres a las expresiones regulares. Por ejemplo, la siguiente definici\u00f3n: 1 DIGIT = [ 0 - 9 ] Les permite definir un d\u00edgito. Aqu\u00ed, DIGIT es el nombre que se le da a la expresi\u00f3n regular que hace match con cualquier caracter que est\u00e9 entre 0 y 9. La siguiente tabla les da una vista general de expresiones regulares comunes que pueden ser especificadas en JLex. Expresi\u00f3n Descripci\u00f3n x el caracter \"x\" \"x\" caracter \"x\", incluso si x es un operador. \\x caracter \u201dx\u201d, incluso si x es un operador. [xy] el caracter x o y [x-z] los caracteres x, y, z [^x] cualquier caracter menos x . cualquier caracter menos newline ^x caracter x al inicio de una linea x caracter x cuando JLex esta en el estado x$ caracter x al final de una linea x? el caracter x es opcional x* el caracter x aparece 0 o m\u00e1s veces x+ el caracter x aparece 1 o m\u00e1s veces x|y caracter x o y (x) caracter x x/y caracter x si y solo si es seguido de un caracter y {xx} hace referencia a la definici\u00f3n xx x{m,n} caracter x aparece entre m y n veces La parte m\u00e1s importante de su analizador l\u00e9xico es la secci\u00f3n de reglas. Una regla en JLex especifica una acci\u00f3n a tomar si la entrada hace match con la expresi\u00f3n regular o definici\u00f3n al principio de la regla. La acci\u00f3n a tomar es especificada escribiendo c\u00f3digo de Java regular. Por ejemplo, asumiendo que un d\u00edgito representa un token en nuestro lenguaje (noten que este no es el caso de COOL), la regla ser\u00eda entonces: 1 2 3 4 { DIGIT } { AbstractSymbol num = AbstractTable . inttable . addString ( yytext ()); return new Symbol ( TokenConstants . INT_CONST , num ); } Esta regla guarda el valor del d\u00edgito en una variable global AbstractTable . inttable y retorna el c\u00f3digo apropiado para el token. Nota Vean la secci\u00f3n 4 para una discusi\u00f3n m\u00e1s detallada de la variable global AbstractTable . inttable y vean la secci\u00f3n 3.2 para una discusi\u00f3n sobre como AbstractTable . inttable es utilizado en el c\u00f3digo de arriba. Un punto importante a recordar es que la entrada actual (es decir, el resultado de llamar a la funci\u00f3n next_token () ) puede hacer match con m\u00faltiples reglas, JLex toma la regla que hace match con el mayor n\u00famero de caracteres. Por ejemplo, si ustedes definieran las siguientes dos reglas: 1 2 [ 0 - 9 ]+ { // action 1 } [ 0 - 9 a - z ]+ { // action 2 } y si la secuencia de caracteres \"2a\" aparece en el archivo que est\u00e1 siendo analizado, entonces la acci\u00f3n 2 va a tomarse, dado que la segunda regla hace match con m\u00e1s caracteres que la primer regla. Si m\u00faltiples reglas hacen match con la misma cantidad de caracteres, entonces la regla que aparece primero es la que se toma. Cuando escriban reglas en JLex, va a ser necesario que se tomen diferentes acciones dependiendo de los tokens encontrados anteriormente. Por ejemplo, cuando esten procesando un token que representa el cierre de un comentario , a ustedes les va a interesar saber si un token que representa abrir comentario se ha encontrado anteriormente. Una forma obvia de tener registro de esto es declarar variables globales en la secci\u00f3n de declaraciones de JLex, que son cambiadas a verdadero cuando ciertos tokens de inter\u00e9s son encontrados. JLex tambi\u00e9n provee una sint\u00e1xis f\u00e1cil ( syntatic sugar ) para poder lograr una funcionalidad similar utilizando declaraciones de estados como: 1 % state COMMENT que puede ser cambiado a true escribiendo yybegin ( COMMENT ) . Para tomar una acci\u00f3n si y solo si un token que representa abrir comentario ha sido encontrado anteriormente. Pueden agregarle un predicado a su regla utilizando la siguiente sint\u00e1xis: 1 2 3 < COMMENT > reg_exp { // action } Hay un estado default llamado YYINITIAL que est\u00e1 activo a menos que ustedes explicitamente indiquen el inicio de un nuevo estado utilizando yybegin ( STATE ) . Ustedes pueden encontrar \u00fatil esta sintaxis para varios aspectos de esta asignaci\u00f3n, as como reportar errores. Nosotros les recomendamos que lean detenidamente la documentaci\u00f3n de JLex que est\u00e1 en el material de apoyo del curso en el GES antes de empezar a escribir su analizador l\u00e9xico. 2. Archivos y Directorios \u00b6 Para empezar, creen el directorio PA1 en su carpeta que contendr\u00e1 todas las dem\u00e1s fases como se explic\u00f3 aqu\u00ed y dentro de esa carpeta en una terminal ( CTRL + T ) escriban lo siguiente: 1 make -f /usr/class/cs143/assignments/PA2J/Makefile Noten que a pesar que esta es la primera asignaci\u00f3n, el directorio se llama PA2 . Todas las asignaciones futuras van a tener un nombre de directorio que es un n\u00famero mayor a la asignaci\u00f3n. Esta situaci\u00f3n sucede debido a que nos saltamos la primer asignaci\u00f3n en este curso. Este comando va a copiar un n\u00famero de archivos en su directorio que han creado. Algunos de los archivos que van a ser copiados van a ser de solo lectura (representando a estos con archivos que realmente son enlaces simb\u00f3licos hacia otros archivos). Ustedes no deber\u00edan de editar estos archivos. De hecho, si ustedes modifican estos archivos, van a encontrar imposible terminar y completar esta asignaci\u00f3n. Vean las instrucciones en el archivo README. Los \u00fanicos archivos que tienen permitido modificar para esta asignaci\u00f3n son: cool.lex : Este archivo contiene un esqueleto para una descripci\u00f3n l\u00e9xica de COOL. Hay comentarios que indican donde ustedes tienen que llenar con c\u00f3digo, pero esto no es necesariamente una gu\u00eda completa. Una parte de la asignaci\u00f3n es que ustede se aseguren que tienen un analizador l\u00e9xico funcional. Exceptuando las secciones indicadas, ustedes son libres de hacer modificaciones a su esqueleto. Ustedes, de hecho, pueden generar un lexer con el archivo base pero este no hace mucho todav\u00eda. Cualquier funci\u00f3n de ayuda que ustedes deseen escribir tiene que ser a\u00f1adida directamente a este archivo en la secci\u00f3n apropiada (vean los comentarios en el archivo). test.cl : Este archivo contiene un programa de COOL ejemplo para que sea analizado. Este archivo no representa toda la especificaci\u00f3n l\u00e9xica del lenguaje COOL, pero de todas maneras es una prueba interesante. Si\u00e9ntanse libres de modificar este archivo para probar su analizador l\u00e9xico. README : Este archivo contiene instrucciones detalladas para la asignaci\u00f3n, as\u00ed como tambi\u00e9n un n\u00famero de recomendaciones \u00fatiles. Realmente este archivo no lo van a modificar, pero es bueno mencionar que lo tienen que leer. Advertencia No modifiquen ning\u00fan archivo que no se menciona en el listado, cuando se evalue la asignaci\u00f3n \u00fanicamente se va a probar el archivo cool.lex en un nuevo entorno. 3. Resultados del Lexer \u00b6 En esta asignaci\u00f3n, ustedes tiene que escribir reglas de JLex que hagan match con las expresiones regulares apropiadas que definan los tokens validos en COOL as\u00ed como se describe en la secci\u00f3n n\u00famero 10 y figura 1 del manual de COOL 2 y tomar las acciones apropiadas, as\u00ed como retornar un token del tipo correcto, guardar el valor del lexema cuando sea necesario, o reportar un error cuando un error se encuentra. Antes de empezar con esta asignaci\u00f3n, aseg\u00farense de haber le\u00eddo la secci\u00f3n 10 y la figura 1 del manual de COOL 2 , luego estudien los diferentes tokens que est\u00e1n definidos en el archivo TokenConstants.java . Su implementaci\u00f3n necesita definir reglas de JLex que hagan match con las expresiones regulares definidas para cada token descrito en el archivo TokenConstants.java y tomar la acci\u00f3n apropiada para cada token. Por ejemplo, si ustedes hacen match del token BOOL_CONST , su analizador l\u00e9xico tiene que guardar el su valor ya sea que sea true o false ; similarmente si hacen match con el token TYPEID , ustedes van a tener que guardar el nombre del tipo. Noten que no todos los tokens requieren que se guarde informaci\u00f3n adicional; por ejemplo, es suficiente que solo se devuelva el tipo de token con el que se hizo match, as\u00ed como cuando se hace match con alg\u00fan keyword del lenguaje como class . Su lexer debe de ser robusto, deber\u00eda de funcionar con cualquier input. Por ejemplo, deber\u00edan de manejar errores como cuando se encuentra un caracter de EOF en medio de un string o comentario, as\u00ed como tambi\u00e9n, como cuando se encuentra con un string que es demasiado largo. Estos son solo algunos de los errores que pueden ser encontrados, lean el manual 2 para conocer el resto. Ustedes tienen que terminar su an\u00e1lisis de forma elegante si alg\u00fan error fatal ocurre. Las excepciones no manejadas NO son aceptables. 3.1 Manejo de Errores \u00b6 Todos los errores deber\u00edan de ser pasados al parser. Su lexer no deber\u00eda de imprimir NADA . Los errores se comunican al parser retornando un token de error especial llamado ERROR junto con el mensaje de error. Nota Ustedes ber\u00edan de ignorar el token error definido tambien en TokenConstants.java y no el token ERROR para esta asignaci\u00f3n ya que este es utilizado \u00fanicamente en el parser. Hay varios requerimientos para reportar errores y recuperarse de errores l\u00e9xicos: Cuando un caracter inv\u00e1lido (alguno que no puede ser alg\u00fan token) se encuentra, un string que contenga solo ese caracter deber\u00eda de ser retornado como el error. Tienen que resumir el an\u00e1lisis con el siguiente caracter. Si un string contiene un newline sin escape ( \\\\ ), tienen que reportar el error como \"Unterminated string constant\" y resumir el an\u00e1lisis l\u00e9xico al principio de la siguiente l\u00ednea. Esto quiere decir que estamos asumiendo que el usuario simplemente olvido cerrar el string con una comilla. Cuando un string es demasiado largo, tienen que reportar el error \"String constant too long\" . Si el string contiene caracteres inv\u00e1lidos (por ejemplo, el caracter nulo \\\\0 ), tienen que reportar esto como \"String contains null character\" . En cualquier caso, el an\u00e1lisis deber\u00eda de continuar hasta el final del string. El final del string es definido tanto como: El principio de la siguiente l\u00ednea si un newline es encontrado despu\u00e9s de encontrar el error. Despu\u00e9s de cerrar el string con \" . Si un comentario se queda abierto y se encuentra el caracter EOF , se tiene que reportar este error con \"EOF in comment\" . Por favor no tokenizen el contenido de los comentarios simplemente porque no se ha cerrado. Similarmente con los strings, si un EOF es encontrado, reporten el error como \"EOF in string constant\" . Si miran un *) fuera de un comentario, tienen que reportar el error como \"Unmatched *)\" , en vez de tokenizar esta secuencia de caracteres como * y como ) . Recuerden de las clases te\u00f3ricas que en esta fase del compilador solo agarra una clase bien limitada de errores. No tomen en cuenta ni verifiquen errores que no son errores l\u00e9xicos en esta asignaci\u00f3n. Por ejemplo, no deber\u00edan de verificar si las variables han sido declaradas anteriormente. Aseg\u00farense de entender que errores la fase de an\u00e1lisis l\u00e9xico puede considerar y cuales no antes de empezar. 3.2 Tabla de Strings \u00b6 Los programas tienden a tener muchas ocurrencias del mismo lexema. Por ejemplo, un identificar es generalmente referenciado m\u00faltiples veces dentro de un programa (de lo contrario no ser\u00eda bastante \u00fatil). Para ahorrarnos un poco de espacio y tiempo, una pr\u00e1ctica com\u00fan en compiladores es guardar los lexemas en una tabla de strings. Nosotros les proveemos una implementaci\u00f3n en Java para esto. Vean las siguientes secciones para m\u00e1s detalles. Hay un problema en decidir como manejar los identificadores especiales para las clases b\u00e1sicas (Object, Int, Bool, String), SELF_TYPE y self. Sin embargo, estos no son un problema hasta en las fases posteriores del compilador. El lexer deber\u00eda de tratar estos identificadores especiales exactamente como otro identificador cualquiera. No verifiquen que las literales enteras caben dentro de la representaci\u00f3n especificada en el manual de COOL 2 . Simplemente creen un Symbol con el literal completo como el contenido del token, sin importar su tama\u00f1o. 3.3 Strings \u00b6 Su analizador l\u00e9xico deberia de convertir los caracteres que se les antepone un caracter de escape en las constantes string a sus valores correctos. Por ejemplo, si el programador escribe los siguientes ocho caracteres: Su analizador l\u00e9xico va a retornar un token STR_CONST cuyo valor sem\u00e1ntico es estos 5 caracteres: Donde \\n representa el caracter de newline de la tabla ASCII. Siguiendo la especificaci\u00f3n de la p\u00e1gina 15 del manual de COOL 2 , ustedes deber\u00edan de retornar un error para un string que contenga el caracter null. Sin embargo, la secuencia de estos dos caracteres: Deber\u00eda de ser convertida a un caracter: 3.4 Otras notas \u00b6 Su analizador l\u00e9xico deber\u00eda de mantener una variable llamada curr_lineno , que indica que l\u00ednea del archivo de entrada est\u00e1 siendo analizada. Esto va a ayudar al parser a imprimir mensajes de error \u00fatiles. Ustedes deber\u00edan de ignorar el token LET_STMT . Es utilizado \u00fanicamente por el parser. Finalmente, noten que si la especificaci\u00f3n l\u00e9xica est\u00e1 incompleta (algunas entradas no tienen expresiones regulares que hagan match), entonces el lexer generado por JLex va a realizar cosas no deseables. Aseg\u00farense de que su especificaci\u00f3n est\u00e9 completa. 4. Notas de Java \u00b6 Cada llamada al lexer retorna el siguiente token y lexema de la entrada. El valor retornado por el m\u00e9todo CoolLexer . next_token es un objeto de la clase java_cup . runtime . Symbol . Este objeto tiene un campo que representa el tipo del token (por ejemplo si es un entero, punto y coma, dos puntos, etc). Los c\u00f3digos sint\u00e1cticos o los tipos de cada token est\u00e1n definidos en el archivo TokenConstants.java . El componente, el valor sem\u00e1ntico o lexema (si el token tiene), tambi\u00e9n es colocado en el objeto java_cup . runtime . Symbol . La documentaci\u00f3n para la clase java_cup . runtime . Symbol est\u00e1 disponible en las referencias 5 . Algunos ejemplos tambi\u00e9n est\u00e1n en el archivo base. Para los identificadores de clase, de objeto, enteros y strings, el valor sem\u00e1ntico tiene que ser de tipo AbstractSymbol . Para las constantes booleanas, el valor sem\u00e1ntico es de tipo java . lang . Boolean . Excepto para los errores (vean abajo), los lexemas para otros tokens no tienen ninguna informaci\u00f3n interesante. Dado que el campo value en la clase java_cup . runtime . Symbol es de tipo Object, ustedes van a necesitar castear este valor antes de utilizarlo o utilizar m\u00e9todos con el valor. Nosotros les proveemos con una implementaci\u00f3n para esto, que esta definida en el archivo AbstractTable.java . Por el momento, ustedes solo necesitan saber que el tipo de entrada a estas tablas es de tipo AbstractSymbol . Cuando un error l\u00e9xico occura, la rutina CoolLexer . next_token deber\u00eda de retornar un java_cup . runtime . Symbol cuyo tipo es TokenConstants . ERROR y cuyo valor sem\u00e1ntico es el mensaje de error. 5. Probando su Lexer \u00b6 Hay al menos dos maneras en la que ustedes pueden probar su analizador l\u00e9xico. La primer forma es generar archivos de entrada y correrlos utilizando su lexer, que imprime la l\u00ednea y el lexema de cada token encontrado por su lexer. La otra forma, cuando piensen que su lexer est\u00e9 funcionando correctamente, prueben correr ./mycoolc para correr su lexer junto con otras fases del compilador (que nosotros les proveemos). Esto va a ser un compilador completo de COOL que pueden probar en cualquier programa. 6. Autograder \u00b6 Ustedes deber\u00edan de bajar el siguiente script en el mismo directorio donde se encuentran sus archivos de la fase n\u00famero 1. 1 2 wget http://raw.githubusercontent.com/CC-4/cc-4.github.io/master/assets/projects/grading/pa1-grading.pl chmod +x pa1-grading.pl Cada vez que quieran ejecutar el autograder deber\u00edan de hacer lo siguiente: 1 ./pa1-grading.pl Referencias \u00b6 JFlex Manual - Manual de JLex. \u21a9 The Cool Reference Manual - Manual de COOL. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 Tour of the Cool Support Code - Manual del C\u00f3digo de Soporte de COOL. \u21a9 SPIM Manual - Manual de SPIM. \u21a9 JCup Java Manual - Javadoc de JCup \u21a9","title":"An\u00e1lisis L\u00e9xico"},{"location":"projects/proj01/#analisis-lexico","text":"Para esta asignaci\u00f3n, van a escribir un analizador l\u00e9xico, tambi\u00e9n llamado lexer, utilizando un generador de analizadores l\u00e9xicos llamado JLex . Ustedes van a describir el set de tokens para COOL en un formato adecuado y JLex va a generar el c\u00f3digo de Java para reconocer tokens en programas escritos en COOL. La documentaci\u00f3n para todas las herramientas del proyecto van a estar disponibles en el material de apoyo del curso en el GES. Esto incluye los manuales de JLex 1 (utilizado para esta asignaci\u00f3n), la documentaci\u00f3n para JCup (utilizado en la siguiente asignaci\u00f3n), as\u00ed como tambi\u00e9n el manual para el simulador SPIM 4 . Ustedes deber\u00edan de trabajar en parejas o individualmente para este proyecto.","title":"An\u00e1lisis L\u00e9xico"},{"location":"projects/proj01/#1-introduccion-a-jlex","text":"JLex permite implementar un analizador l\u00e9xico escribiendo expresiones regulares y establecer acciones cuando alguna secuencia de caracteres hace match con alguna de estas. JLex convierte estas reglas que ustedes van a definir en un archivo llamado lexer.lex en un archivo de Java con el c\u00f3digo que implementa un aut\u00f3mata finito que puede reconocer estas expresiones regulares que ustedes especificaron en el archivo lexer.lex . Afortunadamente, no es necesario entender o incluso mirar lo que autom\u00e1ticamente genera JLex. Los archivos que entiende JLex estan estructurados de la siguiente manera: 1 2 3 4 5 6 7 8 %{ Declaraciones %} Definiciones %% Reglas %% Subrutinas de Usuario Las secciones de Declaraciones y Subrutinas de Usuario son opcionales y les permite a ustedes escribir declaraciones y funciones de ayuda en Java. Las secci\u00f3n de Definiciones tambi\u00e9n es opcional, pero en general es bastante \u00fatil porque las definiciones les permiten a ustedes darle nombres a las expresiones regulares. Por ejemplo, la siguiente definici\u00f3n: 1 DIGIT = [ 0 - 9 ] Les permite definir un d\u00edgito. Aqu\u00ed, DIGIT es el nombre que se le da a la expresi\u00f3n regular que hace match con cualquier caracter que est\u00e9 entre 0 y 9. La siguiente tabla les da una vista general de expresiones regulares comunes que pueden ser especificadas en JLex. Expresi\u00f3n Descripci\u00f3n x el caracter \"x\" \"x\" caracter \"x\", incluso si x es un operador. \\x caracter \u201dx\u201d, incluso si x es un operador. [xy] el caracter x o y [x-z] los caracteres x, y, z [^x] cualquier caracter menos x . cualquier caracter menos newline ^x caracter x al inicio de una linea x caracter x cuando JLex esta en el estado x$ caracter x al final de una linea x? el caracter x es opcional x* el caracter x aparece 0 o m\u00e1s veces x+ el caracter x aparece 1 o m\u00e1s veces x|y caracter x o y (x) caracter x x/y caracter x si y solo si es seguido de un caracter y {xx} hace referencia a la definici\u00f3n xx x{m,n} caracter x aparece entre m y n veces La parte m\u00e1s importante de su analizador l\u00e9xico es la secci\u00f3n de reglas. Una regla en JLex especifica una acci\u00f3n a tomar si la entrada hace match con la expresi\u00f3n regular o definici\u00f3n al principio de la regla. La acci\u00f3n a tomar es especificada escribiendo c\u00f3digo de Java regular. Por ejemplo, asumiendo que un d\u00edgito representa un token en nuestro lenguaje (noten que este no es el caso de COOL), la regla ser\u00eda entonces: 1 2 3 4 { DIGIT } { AbstractSymbol num = AbstractTable . inttable . addString ( yytext ()); return new Symbol ( TokenConstants . INT_CONST , num ); } Esta regla guarda el valor del d\u00edgito en una variable global AbstractTable . inttable y retorna el c\u00f3digo apropiado para el token. Nota Vean la secci\u00f3n 4 para una discusi\u00f3n m\u00e1s detallada de la variable global AbstractTable . inttable y vean la secci\u00f3n 3.2 para una discusi\u00f3n sobre como AbstractTable . inttable es utilizado en el c\u00f3digo de arriba. Un punto importante a recordar es que la entrada actual (es decir, el resultado de llamar a la funci\u00f3n next_token () ) puede hacer match con m\u00faltiples reglas, JLex toma la regla que hace match con el mayor n\u00famero de caracteres. Por ejemplo, si ustedes definieran las siguientes dos reglas: 1 2 [ 0 - 9 ]+ { // action 1 } [ 0 - 9 a - z ]+ { // action 2 } y si la secuencia de caracteres \"2a\" aparece en el archivo que est\u00e1 siendo analizado, entonces la acci\u00f3n 2 va a tomarse, dado que la segunda regla hace match con m\u00e1s caracteres que la primer regla. Si m\u00faltiples reglas hacen match con la misma cantidad de caracteres, entonces la regla que aparece primero es la que se toma. Cuando escriban reglas en JLex, va a ser necesario que se tomen diferentes acciones dependiendo de los tokens encontrados anteriormente. Por ejemplo, cuando esten procesando un token que representa el cierre de un comentario , a ustedes les va a interesar saber si un token que representa abrir comentario se ha encontrado anteriormente. Una forma obvia de tener registro de esto es declarar variables globales en la secci\u00f3n de declaraciones de JLex, que son cambiadas a verdadero cuando ciertos tokens de inter\u00e9s son encontrados. JLex tambi\u00e9n provee una sint\u00e1xis f\u00e1cil ( syntatic sugar ) para poder lograr una funcionalidad similar utilizando declaraciones de estados como: 1 % state COMMENT que puede ser cambiado a true escribiendo yybegin ( COMMENT ) . Para tomar una acci\u00f3n si y solo si un token que representa abrir comentario ha sido encontrado anteriormente. Pueden agregarle un predicado a su regla utilizando la siguiente sint\u00e1xis: 1 2 3 < COMMENT > reg_exp { // action } Hay un estado default llamado YYINITIAL que est\u00e1 activo a menos que ustedes explicitamente indiquen el inicio de un nuevo estado utilizando yybegin ( STATE ) . Ustedes pueden encontrar \u00fatil esta sintaxis para varios aspectos de esta asignaci\u00f3n, as como reportar errores. Nosotros les recomendamos que lean detenidamente la documentaci\u00f3n de JLex que est\u00e1 en el material de apoyo del curso en el GES antes de empezar a escribir su analizador l\u00e9xico.","title":"1. Introducci\u00f3n a JLex"},{"location":"projects/proj01/#2-archivos-y-directorios","text":"Para empezar, creen el directorio PA1 en su carpeta que contendr\u00e1 todas las dem\u00e1s fases como se explic\u00f3 aqu\u00ed y dentro de esa carpeta en una terminal ( CTRL + T ) escriban lo siguiente: 1 make -f /usr/class/cs143/assignments/PA2J/Makefile Noten que a pesar que esta es la primera asignaci\u00f3n, el directorio se llama PA2 . Todas las asignaciones futuras van a tener un nombre de directorio que es un n\u00famero mayor a la asignaci\u00f3n. Esta situaci\u00f3n sucede debido a que nos saltamos la primer asignaci\u00f3n en este curso. Este comando va a copiar un n\u00famero de archivos en su directorio que han creado. Algunos de los archivos que van a ser copiados van a ser de solo lectura (representando a estos con archivos que realmente son enlaces simb\u00f3licos hacia otros archivos). Ustedes no deber\u00edan de editar estos archivos. De hecho, si ustedes modifican estos archivos, van a encontrar imposible terminar y completar esta asignaci\u00f3n. Vean las instrucciones en el archivo README. Los \u00fanicos archivos que tienen permitido modificar para esta asignaci\u00f3n son: cool.lex : Este archivo contiene un esqueleto para una descripci\u00f3n l\u00e9xica de COOL. Hay comentarios que indican donde ustedes tienen que llenar con c\u00f3digo, pero esto no es necesariamente una gu\u00eda completa. Una parte de la asignaci\u00f3n es que ustede se aseguren que tienen un analizador l\u00e9xico funcional. Exceptuando las secciones indicadas, ustedes son libres de hacer modificaciones a su esqueleto. Ustedes, de hecho, pueden generar un lexer con el archivo base pero este no hace mucho todav\u00eda. Cualquier funci\u00f3n de ayuda que ustedes deseen escribir tiene que ser a\u00f1adida directamente a este archivo en la secci\u00f3n apropiada (vean los comentarios en el archivo). test.cl : Este archivo contiene un programa de COOL ejemplo para que sea analizado. Este archivo no representa toda la especificaci\u00f3n l\u00e9xica del lenguaje COOL, pero de todas maneras es una prueba interesante. Si\u00e9ntanse libres de modificar este archivo para probar su analizador l\u00e9xico. README : Este archivo contiene instrucciones detalladas para la asignaci\u00f3n, as\u00ed como tambi\u00e9n un n\u00famero de recomendaciones \u00fatiles. Realmente este archivo no lo van a modificar, pero es bueno mencionar que lo tienen que leer. Advertencia No modifiquen ning\u00fan archivo que no se menciona en el listado, cuando se evalue la asignaci\u00f3n \u00fanicamente se va a probar el archivo cool.lex en un nuevo entorno.","title":"2. Archivos y Directorios"},{"location":"projects/proj01/#3-resultados-del-lexer","text":"En esta asignaci\u00f3n, ustedes tiene que escribir reglas de JLex que hagan match con las expresiones regulares apropiadas que definan los tokens validos en COOL as\u00ed como se describe en la secci\u00f3n n\u00famero 10 y figura 1 del manual de COOL 2 y tomar las acciones apropiadas, as\u00ed como retornar un token del tipo correcto, guardar el valor del lexema cuando sea necesario, o reportar un error cuando un error se encuentra. Antes de empezar con esta asignaci\u00f3n, aseg\u00farense de haber le\u00eddo la secci\u00f3n 10 y la figura 1 del manual de COOL 2 , luego estudien los diferentes tokens que est\u00e1n definidos en el archivo TokenConstants.java . Su implementaci\u00f3n necesita definir reglas de JLex que hagan match con las expresiones regulares definidas para cada token descrito en el archivo TokenConstants.java y tomar la acci\u00f3n apropiada para cada token. Por ejemplo, si ustedes hacen match del token BOOL_CONST , su analizador l\u00e9xico tiene que guardar el su valor ya sea que sea true o false ; similarmente si hacen match con el token TYPEID , ustedes van a tener que guardar el nombre del tipo. Noten que no todos los tokens requieren que se guarde informaci\u00f3n adicional; por ejemplo, es suficiente que solo se devuelva el tipo de token con el que se hizo match, as\u00ed como cuando se hace match con alg\u00fan keyword del lenguaje como class . Su lexer debe de ser robusto, deber\u00eda de funcionar con cualquier input. Por ejemplo, deber\u00edan de manejar errores como cuando se encuentra un caracter de EOF en medio de un string o comentario, as\u00ed como tambi\u00e9n, como cuando se encuentra con un string que es demasiado largo. Estos son solo algunos de los errores que pueden ser encontrados, lean el manual 2 para conocer el resto. Ustedes tienen que terminar su an\u00e1lisis de forma elegante si alg\u00fan error fatal ocurre. Las excepciones no manejadas NO son aceptables.","title":"3. Resultados del Lexer"},{"location":"projects/proj01/#31-manejo-de-errores","text":"Todos los errores deber\u00edan de ser pasados al parser. Su lexer no deber\u00eda de imprimir NADA . Los errores se comunican al parser retornando un token de error especial llamado ERROR junto con el mensaje de error. Nota Ustedes ber\u00edan de ignorar el token error definido tambien en TokenConstants.java y no el token ERROR para esta asignaci\u00f3n ya que este es utilizado \u00fanicamente en el parser. Hay varios requerimientos para reportar errores y recuperarse de errores l\u00e9xicos: Cuando un caracter inv\u00e1lido (alguno que no puede ser alg\u00fan token) se encuentra, un string que contenga solo ese caracter deber\u00eda de ser retornado como el error. Tienen que resumir el an\u00e1lisis con el siguiente caracter. Si un string contiene un newline sin escape ( \\\\ ), tienen que reportar el error como \"Unterminated string constant\" y resumir el an\u00e1lisis l\u00e9xico al principio de la siguiente l\u00ednea. Esto quiere decir que estamos asumiendo que el usuario simplemente olvido cerrar el string con una comilla. Cuando un string es demasiado largo, tienen que reportar el error \"String constant too long\" . Si el string contiene caracteres inv\u00e1lidos (por ejemplo, el caracter nulo \\\\0 ), tienen que reportar esto como \"String contains null character\" . En cualquier caso, el an\u00e1lisis deber\u00eda de continuar hasta el final del string. El final del string es definido tanto como: El principio de la siguiente l\u00ednea si un newline es encontrado despu\u00e9s de encontrar el error. Despu\u00e9s de cerrar el string con \" . Si un comentario se queda abierto y se encuentra el caracter EOF , se tiene que reportar este error con \"EOF in comment\" . Por favor no tokenizen el contenido de los comentarios simplemente porque no se ha cerrado. Similarmente con los strings, si un EOF es encontrado, reporten el error como \"EOF in string constant\" . Si miran un *) fuera de un comentario, tienen que reportar el error como \"Unmatched *)\" , en vez de tokenizar esta secuencia de caracteres como * y como ) . Recuerden de las clases te\u00f3ricas que en esta fase del compilador solo agarra una clase bien limitada de errores. No tomen en cuenta ni verifiquen errores que no son errores l\u00e9xicos en esta asignaci\u00f3n. Por ejemplo, no deber\u00edan de verificar si las variables han sido declaradas anteriormente. Aseg\u00farense de entender que errores la fase de an\u00e1lisis l\u00e9xico puede considerar y cuales no antes de empezar.","title":"3.1 Manejo de Errores"},{"location":"projects/proj01/#32-tabla-de-strings","text":"Los programas tienden a tener muchas ocurrencias del mismo lexema. Por ejemplo, un identificar es generalmente referenciado m\u00faltiples veces dentro de un programa (de lo contrario no ser\u00eda bastante \u00fatil). Para ahorrarnos un poco de espacio y tiempo, una pr\u00e1ctica com\u00fan en compiladores es guardar los lexemas en una tabla de strings. Nosotros les proveemos una implementaci\u00f3n en Java para esto. Vean las siguientes secciones para m\u00e1s detalles. Hay un problema en decidir como manejar los identificadores especiales para las clases b\u00e1sicas (Object, Int, Bool, String), SELF_TYPE y self. Sin embargo, estos no son un problema hasta en las fases posteriores del compilador. El lexer deber\u00eda de tratar estos identificadores especiales exactamente como otro identificador cualquiera. No verifiquen que las literales enteras caben dentro de la representaci\u00f3n especificada en el manual de COOL 2 . Simplemente creen un Symbol con el literal completo como el contenido del token, sin importar su tama\u00f1o.","title":"3.2 Tabla de Strings"},{"location":"projects/proj01/#33-strings","text":"Su analizador l\u00e9xico deberia de convertir los caracteres que se les antepone un caracter de escape en las constantes string a sus valores correctos. Por ejemplo, si el programador escribe los siguientes ocho caracteres: Su analizador l\u00e9xico va a retornar un token STR_CONST cuyo valor sem\u00e1ntico es estos 5 caracteres: Donde \\n representa el caracter de newline de la tabla ASCII. Siguiendo la especificaci\u00f3n de la p\u00e1gina 15 del manual de COOL 2 , ustedes deber\u00edan de retornar un error para un string que contenga el caracter null. Sin embargo, la secuencia de estos dos caracteres: Deber\u00eda de ser convertida a un caracter:","title":"3.3 Strings"},{"location":"projects/proj01/#34-otras-notas","text":"Su analizador l\u00e9xico deber\u00eda de mantener una variable llamada curr_lineno , que indica que l\u00ednea del archivo de entrada est\u00e1 siendo analizada. Esto va a ayudar al parser a imprimir mensajes de error \u00fatiles. Ustedes deber\u00edan de ignorar el token LET_STMT . Es utilizado \u00fanicamente por el parser. Finalmente, noten que si la especificaci\u00f3n l\u00e9xica est\u00e1 incompleta (algunas entradas no tienen expresiones regulares que hagan match), entonces el lexer generado por JLex va a realizar cosas no deseables. Aseg\u00farense de que su especificaci\u00f3n est\u00e9 completa.","title":"3.4 Otras notas"},{"location":"projects/proj01/#4-notas-de-java","text":"Cada llamada al lexer retorna el siguiente token y lexema de la entrada. El valor retornado por el m\u00e9todo CoolLexer . next_token es un objeto de la clase java_cup . runtime . Symbol . Este objeto tiene un campo que representa el tipo del token (por ejemplo si es un entero, punto y coma, dos puntos, etc). Los c\u00f3digos sint\u00e1cticos o los tipos de cada token est\u00e1n definidos en el archivo TokenConstants.java . El componente, el valor sem\u00e1ntico o lexema (si el token tiene), tambi\u00e9n es colocado en el objeto java_cup . runtime . Symbol . La documentaci\u00f3n para la clase java_cup . runtime . Symbol est\u00e1 disponible en las referencias 5 . Algunos ejemplos tambi\u00e9n est\u00e1n en el archivo base. Para los identificadores de clase, de objeto, enteros y strings, el valor sem\u00e1ntico tiene que ser de tipo AbstractSymbol . Para las constantes booleanas, el valor sem\u00e1ntico es de tipo java . lang . Boolean . Excepto para los errores (vean abajo), los lexemas para otros tokens no tienen ninguna informaci\u00f3n interesante. Dado que el campo value en la clase java_cup . runtime . Symbol es de tipo Object, ustedes van a necesitar castear este valor antes de utilizarlo o utilizar m\u00e9todos con el valor. Nosotros les proveemos con una implementaci\u00f3n para esto, que esta definida en el archivo AbstractTable.java . Por el momento, ustedes solo necesitan saber que el tipo de entrada a estas tablas es de tipo AbstractSymbol . Cuando un error l\u00e9xico occura, la rutina CoolLexer . next_token deber\u00eda de retornar un java_cup . runtime . Symbol cuyo tipo es TokenConstants . ERROR y cuyo valor sem\u00e1ntico es el mensaje de error.","title":"4. Notas de Java"},{"location":"projects/proj01/#5-probando-su-lexer","text":"Hay al menos dos maneras en la que ustedes pueden probar su analizador l\u00e9xico. La primer forma es generar archivos de entrada y correrlos utilizando su lexer, que imprime la l\u00ednea y el lexema de cada token encontrado por su lexer. La otra forma, cuando piensen que su lexer est\u00e9 funcionando correctamente, prueben correr ./mycoolc para correr su lexer junto con otras fases del compilador (que nosotros les proveemos). Esto va a ser un compilador completo de COOL que pueden probar en cualquier programa.","title":"5. Probando su Lexer"},{"location":"projects/proj01/#6-autograder","text":"Ustedes deber\u00edan de bajar el siguiente script en el mismo directorio donde se encuentran sus archivos de la fase n\u00famero 1. 1 2 wget http://raw.githubusercontent.com/CC-4/cc-4.github.io/master/assets/projects/grading/pa1-grading.pl chmod +x pa1-grading.pl Cada vez que quieran ejecutar el autograder deber\u00edan de hacer lo siguiente: 1 ./pa1-grading.pl","title":"6. Autograder"},{"location":"projects/proj01/#referencias","text":"JFlex Manual - Manual de JLex. \u21a9 The Cool Reference Manual - Manual de COOL. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 Tour of the Cool Support Code - Manual del C\u00f3digo de Soporte de COOL. \u21a9 SPIM Manual - Manual de SPIM. \u21a9 JCup Java Manual - Javadoc de JCup \u21a9","title":"Referencias"},{"location":"projects/proj02/","text":"An\u00e1lisis Sint\u00e1ctico \u00b6 En esta asignaci\u00f3n ustedes van a escribir un parser para COOL. La asignaci\u00f3n hace uso de dos herramientas: el generador de parser JCup y el paquete de Java con las clases que representan los nodos de un \u00e1rbol sint\u00e1ctico. La salida de su parser va a ser un \u00e1rbol sint\u00e1ctico abstracto o AST por sus siglas en ingl\u00e9s. Van a construir un AST utilizando acciones sem\u00e1nticas del generador de parser JCup. Ustedes van a necesitar consultar la estructura sint\u00e1ctica de COOL, que se encuentra en la figura 1 del manual de referencia 3 as\u00ed como otras partes tambi\u00e9n. La documentaci\u00f3n de JCup est\u00e1 disponible en l\u00ednea 2 . La documentaci\u00f3n del paquete tree tambi\u00e9n est\u00e1 disponible en l\u00ednea 1 . Ustedes van a necesitar la informaci\u00f3n del paquete tree para esta y futuras asignaciones. Hay mucha informaci\u00f3n en este documento, y necesitan saber la mayor\u00eda para poder escribir un parser funcional. Por favor lean este documento detenida y cautelosamente poni\u00e9ndole mucha atenci\u00f3n a los detalles. 1. Archivos y Directorios \u00b6 Para empezar, creen el directorio PA2 en su carpeta que contendr\u00e1 todas las dem\u00e1s fases como se explic\u00f3 aqu\u00ed y dentro de esa carpeta en una terminal ( CTRL + T ) escriban lo siguiente: 1 make -f /usr/class/cs143/assignments/PA3J/Makefile Este comando va a copiar un n\u00famero de archivos en su directorio que han creado. Algunos de los archivos que van a ser copiados van a ser de solo lectura (representando a estos con archivos que realmente son enlaces simb\u00f3licos hacia otros archivos). Ustedes no deber\u00edan de editar estos archivos. De hecho, si ustedes modifican estos archivos, van a encontrar imposible terminar y completar esta asignaci\u00f3n. Vean las instrucciones en el archivo README. Los \u00fanicos archivos que tienen permitido modificar para esta asignaci\u00f3n son: cool.cup : Este archivo contiene un esqueleto que describe un parser para COOL. La secci\u00f3n de declaraciones est\u00e1 casi completa, pero van a necesitar agregar alguna que otra declaraci\u00f3n para definir nuevos no terminales . Nosotros les hemos dado ya los nombres y tipos de declaraci\u00f3n para los terminales de la gram\u00e1tica. Ustedes tienen que agregar declaraciones de precedencia tambi\u00e9n. La secci\u00f3n de reglas, sin embargo, est\u00e1 incompleta. Les hemos prove\u00eddo algunas partes para algunas reglas. Ustedes no deber\u00edan de modificar este c\u00f3digo para tener una soluci\u00f3n funcional, pero est\u00e1 permitido que lo modifiquen si ustedes desean. Por favor, no asuman que alguna regla particular dada est\u00e1 completa. good.cl y bad.cl : Estos archivos prueban algunas caracter\u00edsticas de la gram\u00e1tica de COOL. Pueden modificar estos archivos como ustedes quieran para probar su parser. README : Este archivo contiene instrucciones detalladas para la asignaci\u00f3n, as\u00ed como tambi\u00e9n un n\u00famero de recomendaciones \u00fatiles. Realmente este archivo no lo van a modificar, pero es bueno mencionar que lo tienen que leer. Advertencia No modifiquen ning\u00fan archivo que no se menciona en el listado, cuando se evalue la asignaci\u00f3n \u00fanicamente se va a probar el archivo cool.cup en un nuevo entorno. 2. Probando el Parser \u00b6 Ustedes van a necesitar un lexer completamente funcional para probar el parser. Pueden utilizar su propio analizador l\u00e9xico del proyecto pasado o utilizar el lexer de coolc. Por default, el lexer de coolc es utilizado, para cambiar este comportamiento, cambien el archivo ejecutable lexer (que es un enlace simb\u00f3lico en su directorio de proyecto) con su propio lexer. No asuman autom\u00e1ticamente que el lexer que utilicen est\u00e1 libre de errores. Algunos bugs latentes en el analizador l\u00e9xico pueden generar problemas misteriosos en el parser. Ustedes van a correr su parser utilizando ./myparser , un shell script que pega el parser con un analizador l\u00e9xico (el de su elecci\u00f3n). Noten que ./myparser puede recibir una bandera -p para depurar el parser; utilizar esta bandera causa que un mont\u00f3n de informaci\u00f3n de lo que el parser est\u00e1 haciendo sea impreso en la terminal. JCup produce las tablas de parseo de una gram\u00e1tica LALR(1) bastante le\u00edbles en un archivo llamado cool.output . Examinar este archivo a veces puede ser \u00fatil para depurar la definici\u00f3n del parser. Ustedes deber\u00edan de probar este parser tanto en archivos bien definidos de COOL, como en malos para ver si todo est\u00e1 funcionando correctamente. Recuerden, los bugs en su parser se pueden manifestar en alguna otra parte m\u00e1s adelante. Su parser va a ser calificado utilizando nuestro analizador l\u00e9xico, entonces si ustedes escogen utilizar unicamente su parser, sepan de antemano que esto est\u00e1 sucediendo en el autograder. Recomendaci\u00f3n Nosotros les recomendamos utilizar el analizador l\u00e9xico de coolc que viene por defecto, ya que este est\u00e1 menos propenso a errores, pero cuando ya tengan un parser funcional utilicen su propio analizar l\u00e9xico para verificar que todo funcione bien. 3. Salida del Parser \u00b6 Sus acciones sem\u00e1nticas deber\u00edan de construir un AST. La ra\u00edz (y solamente la ra\u00edz) del AST deber\u00eda de ser de tipo programc . Para los programas que son parseados satisfactoriamente, la salida del parser es un listado del AST. Para programas que contengan errores (l\u00e9xicos o sint\u00e1cticos), la salida son mensajes de error del parser. Nosotros les hemos prove\u00eddo con una funci\u00f3n que reporta errores imprimiendo los mensajes en un formato est\u00e1ndar; por favor NO modifiquen esto. Ustedes no deber\u00edan de invocar esta funci\u00f3n directamente en las acciones sem\u00e1nticas; JCup autom\u00e1ticamente invoca a esta funci\u00f3n cuando un error es detectado. Para algunos constructs que puedan abarcar varias l\u00edneas de c\u00f3digo, por ejemplo: 1 2 3 4 5 foo ( 1 , 2 , 3 ) este dispatch abarca 5 l\u00edneas, de la 1 a la 5, ustedes cuando construyan alg\u00fan nodo que abarque m\u00faltiples l\u00edneas son libres de indicar a que n\u00famero de l\u00ednea pertence este nodo, siempre y cuando, el n\u00famero est\u00e9 en el rango que abarque el nodo, en el ejemplo anterior podr\u00eda ser 1, 2, 3, 4 o 5. No se preocupen si las l\u00edneas reportadas por su parser no hacen match exactamente como el compilador de referencia coolc. Tambi\u00e9n su parser solo deber\u00eda de funcionar para programas que est\u00e9n contenidos en un solo archivo. No se preocupen por compilar m\u00faltiples archivos. Recomendaci\u00f3n Siempre que reporten el n\u00famero de l\u00ednea utilicen la funci\u00f3n de ayuda curr_lineno () que se encuentra en cool.cup . 4. Manejo de Errores \u00b6 Ustedes deber\u00edan de utilizar el pseudo no terminal error para manejar errores en el parser. El prop\u00f3sito de error es permitirle al parser continuar despu\u00e9s de un error anticipado. No es un panacea y el parser puede volverse completamente confuso. Vean la documentaci\u00f3n de JCup 2 para saber como utilizar error correctamente. Para recibir toda la nota, su parser deber\u00eda de recuperarse por lo menos en las siguientes situaciones: Si hay alg\u00fan error en una definici\u00f3n de clase pero la clase es terminada correctamente y la siguiente clase est\u00e1 correcta sint\u00e1cticamente, el parser deber\u00eda de ser capaz de empezar de nuevo en la siguiente definici\u00f3n de clase. Similarmente, el parser deber\u00eda de recuperarse de errores en las caracter\u00edsticas (yendo a la siguiente caracter\u00edstica). En un let , yendo a la siguiente variable. En un bloque, yendo a la siguiente expresi\u00f3n. No se preocupen demasiado por los n\u00fameros de l\u00ednea que aparecen en los mensajes de error que su parser genera. Si su parser est\u00e1 funcionando correctamente, el n\u00famero de l\u00ednea generalmente va a ser la l\u00ednea donde se encontr\u00f3 el error. Para constructs erroneos que abarquen m\u00faltiples l\u00edneas, el n\u00famero de l\u00ednea por lo general va a ser la \u00faltima l\u00ednea del construct. 5. Observaciones \u00b6 Ustedes van a necesitar declaraciones de precedencia, pero solo para las expresiones. No utilicen declaraciones de precedencia ciegamente (es decir, no resuelvan un conflicto shift-reduce en su gram\u00e1tica agregando reglas de precedencia hasta que ya no aparezca). El let de COOL introduce una ambiguedad en el lenguage (traten de construir un ejemplo si es que no est\u00e1n convencidos). El manual resuelve esta ambiguedad diciendo que el let se extiende a la derecha tanto como se pueda. Dependiendo de como su gram\u00e1tica sea escrita, esta ambiguedad puede aparecer en su parser como un conflicto shift-reduce involucrando las producciones del let. Si ustedes se encuentran en esta situaci\u00f3n, talvez quieran considerar resolver el problema utilizando caracter\u00edsticas de JCup que permitan que la precedencia sea asociada a las producciones (no solamente a los operadores). Vean la documentaci\u00f3n de JCup 2 para obtener informaci\u00f3n en como utilizar esta caracter\u00edstica. Dado que el compilador ./mycoolc utiliza pipes para comunicar de una fase a la siguiente, cualquier caracter extra\u00f1o producido por el parser puede causar errores, en particular, el analizador sem\u00e1ntico no pueda analizar el AST que su parser produce. Dado que cualquier print utilizado en su c\u00f3digo puede causar que pierdan errores, por favor aseg\u00farense de remover cualquier print de su c\u00f3digo antes de probar el autograder de esta asignaci\u00f3n. 6. Notas de Java \u00b6 Ustedes deber\u00edan de declarar \"tipos\" para sus no terminales y los terminales que tengan valor, por ejemplo, en el archivo cool.cup est\u00e1 la declaraci\u00f3n: 1 nonterminal programc program ; Esta declaraci\u00f3n dice que el no terminal program tiene tipo programc . Es cr\u00edtico que ustedes declaren el tipo correcto para los atributos de los s\u00edmbolos de la gram\u00e1tica, fallar en hacerlo virtualmente hace que su parser no funcione correctamente. Ustedes no necesitan declarar tipos para los s\u00edmbolos de la gram\u00e1tica que no tengan atributos. El chequeo de tipos del compilador de java javac se puede quejar si utilizan los constructores de los nodos del \u00e1rbol con el tipo incorrecto. Si ustedes corrigen los errores con casting, su programa puede lanzar una excepci\u00f3n cuando el constructor note que est\u00e1 siendo utilizado con los tipos incorrectos. Tambi\u00e9n, JCup se puede quejar si crean errores de tipos. 7. Autograder \u00b6 Ustedes deber\u00edan de descargar el siguiente script en el mismo directorio donde tienen sus archivos de la segunda fase: 1 2 wget http://raw.githubusercontent.com/CC-4/cc-4.github.io/master/assets/projects/grading/pa2-grading.pl chmod +x pa2-grading.pl y ejecutar el siguiente comando: 1 ./pa2-grading.pl Esto califica su parser utilizando el analizador l\u00e9xico de coolc. Si ustedes quieren probar su parser utilizando la fase 1: 1 2 wget http://raw.githubusercontent.com/CC-4/cc-4.github.io/master/assets/projects/grading/pa2-grading-all.sh chmod +x pa2-grading-all.sh y ejecutar el siguiente comando: 1 ./pa2-grading-all.sh Referencias \u00b6 The Tree Package - Javadoc del paquete Tree. \u21a9 JCup Manual - Manual de JCup \u21a9 \u21a9 \u21a9 The Cool Reference Manual - Manual de COOL. \u21a9 Tour of the Cool Support Code - Manual del C\u00f3digo de Soporte de COOL. \u21a9 SPIM Manual - Manual de SPIM. \u21a9 JCup Java Manual - Javadoc de JCup \u21a9","title":"An\u00e1lisis Sint\u00e1ctico"},{"location":"projects/proj02/#analisis-sintactico","text":"En esta asignaci\u00f3n ustedes van a escribir un parser para COOL. La asignaci\u00f3n hace uso de dos herramientas: el generador de parser JCup y el paquete de Java con las clases que representan los nodos de un \u00e1rbol sint\u00e1ctico. La salida de su parser va a ser un \u00e1rbol sint\u00e1ctico abstracto o AST por sus siglas en ingl\u00e9s. Van a construir un AST utilizando acciones sem\u00e1nticas del generador de parser JCup. Ustedes van a necesitar consultar la estructura sint\u00e1ctica de COOL, que se encuentra en la figura 1 del manual de referencia 3 as\u00ed como otras partes tambi\u00e9n. La documentaci\u00f3n de JCup est\u00e1 disponible en l\u00ednea 2 . La documentaci\u00f3n del paquete tree tambi\u00e9n est\u00e1 disponible en l\u00ednea 1 . Ustedes van a necesitar la informaci\u00f3n del paquete tree para esta y futuras asignaciones. Hay mucha informaci\u00f3n en este documento, y necesitan saber la mayor\u00eda para poder escribir un parser funcional. Por favor lean este documento detenida y cautelosamente poni\u00e9ndole mucha atenci\u00f3n a los detalles.","title":"An\u00e1lisis Sint\u00e1ctico"},{"location":"projects/proj02/#1-archivos-y-directorios","text":"Para empezar, creen el directorio PA2 en su carpeta que contendr\u00e1 todas las dem\u00e1s fases como se explic\u00f3 aqu\u00ed y dentro de esa carpeta en una terminal ( CTRL + T ) escriban lo siguiente: 1 make -f /usr/class/cs143/assignments/PA3J/Makefile Este comando va a copiar un n\u00famero de archivos en su directorio que han creado. Algunos de los archivos que van a ser copiados van a ser de solo lectura (representando a estos con archivos que realmente son enlaces simb\u00f3licos hacia otros archivos). Ustedes no deber\u00edan de editar estos archivos. De hecho, si ustedes modifican estos archivos, van a encontrar imposible terminar y completar esta asignaci\u00f3n. Vean las instrucciones en el archivo README. Los \u00fanicos archivos que tienen permitido modificar para esta asignaci\u00f3n son: cool.cup : Este archivo contiene un esqueleto que describe un parser para COOL. La secci\u00f3n de declaraciones est\u00e1 casi completa, pero van a necesitar agregar alguna que otra declaraci\u00f3n para definir nuevos no terminales . Nosotros les hemos dado ya los nombres y tipos de declaraci\u00f3n para los terminales de la gram\u00e1tica. Ustedes tienen que agregar declaraciones de precedencia tambi\u00e9n. La secci\u00f3n de reglas, sin embargo, est\u00e1 incompleta. Les hemos prove\u00eddo algunas partes para algunas reglas. Ustedes no deber\u00edan de modificar este c\u00f3digo para tener una soluci\u00f3n funcional, pero est\u00e1 permitido que lo modifiquen si ustedes desean. Por favor, no asuman que alguna regla particular dada est\u00e1 completa. good.cl y bad.cl : Estos archivos prueban algunas caracter\u00edsticas de la gram\u00e1tica de COOL. Pueden modificar estos archivos como ustedes quieran para probar su parser. README : Este archivo contiene instrucciones detalladas para la asignaci\u00f3n, as\u00ed como tambi\u00e9n un n\u00famero de recomendaciones \u00fatiles. Realmente este archivo no lo van a modificar, pero es bueno mencionar que lo tienen que leer. Advertencia No modifiquen ning\u00fan archivo que no se menciona en el listado, cuando se evalue la asignaci\u00f3n \u00fanicamente se va a probar el archivo cool.cup en un nuevo entorno.","title":"1. Archivos y Directorios"},{"location":"projects/proj02/#2-probando-el-parser","text":"Ustedes van a necesitar un lexer completamente funcional para probar el parser. Pueden utilizar su propio analizador l\u00e9xico del proyecto pasado o utilizar el lexer de coolc. Por default, el lexer de coolc es utilizado, para cambiar este comportamiento, cambien el archivo ejecutable lexer (que es un enlace simb\u00f3lico en su directorio de proyecto) con su propio lexer. No asuman autom\u00e1ticamente que el lexer que utilicen est\u00e1 libre de errores. Algunos bugs latentes en el analizador l\u00e9xico pueden generar problemas misteriosos en el parser. Ustedes van a correr su parser utilizando ./myparser , un shell script que pega el parser con un analizador l\u00e9xico (el de su elecci\u00f3n). Noten que ./myparser puede recibir una bandera -p para depurar el parser; utilizar esta bandera causa que un mont\u00f3n de informaci\u00f3n de lo que el parser est\u00e1 haciendo sea impreso en la terminal. JCup produce las tablas de parseo de una gram\u00e1tica LALR(1) bastante le\u00edbles en un archivo llamado cool.output . Examinar este archivo a veces puede ser \u00fatil para depurar la definici\u00f3n del parser. Ustedes deber\u00edan de probar este parser tanto en archivos bien definidos de COOL, como en malos para ver si todo est\u00e1 funcionando correctamente. Recuerden, los bugs en su parser se pueden manifestar en alguna otra parte m\u00e1s adelante. Su parser va a ser calificado utilizando nuestro analizador l\u00e9xico, entonces si ustedes escogen utilizar unicamente su parser, sepan de antemano que esto est\u00e1 sucediendo en el autograder. Recomendaci\u00f3n Nosotros les recomendamos utilizar el analizador l\u00e9xico de coolc que viene por defecto, ya que este est\u00e1 menos propenso a errores, pero cuando ya tengan un parser funcional utilicen su propio analizar l\u00e9xico para verificar que todo funcione bien.","title":"2. Probando el Parser"},{"location":"projects/proj02/#3-salida-del-parser","text":"Sus acciones sem\u00e1nticas deber\u00edan de construir un AST. La ra\u00edz (y solamente la ra\u00edz) del AST deber\u00eda de ser de tipo programc . Para los programas que son parseados satisfactoriamente, la salida del parser es un listado del AST. Para programas que contengan errores (l\u00e9xicos o sint\u00e1cticos), la salida son mensajes de error del parser. Nosotros les hemos prove\u00eddo con una funci\u00f3n que reporta errores imprimiendo los mensajes en un formato est\u00e1ndar; por favor NO modifiquen esto. Ustedes no deber\u00edan de invocar esta funci\u00f3n directamente en las acciones sem\u00e1nticas; JCup autom\u00e1ticamente invoca a esta funci\u00f3n cuando un error es detectado. Para algunos constructs que puedan abarcar varias l\u00edneas de c\u00f3digo, por ejemplo: 1 2 3 4 5 foo ( 1 , 2 , 3 ) este dispatch abarca 5 l\u00edneas, de la 1 a la 5, ustedes cuando construyan alg\u00fan nodo que abarque m\u00faltiples l\u00edneas son libres de indicar a que n\u00famero de l\u00ednea pertence este nodo, siempre y cuando, el n\u00famero est\u00e9 en el rango que abarque el nodo, en el ejemplo anterior podr\u00eda ser 1, 2, 3, 4 o 5. No se preocupen si las l\u00edneas reportadas por su parser no hacen match exactamente como el compilador de referencia coolc. Tambi\u00e9n su parser solo deber\u00eda de funcionar para programas que est\u00e9n contenidos en un solo archivo. No se preocupen por compilar m\u00faltiples archivos. Recomendaci\u00f3n Siempre que reporten el n\u00famero de l\u00ednea utilicen la funci\u00f3n de ayuda curr_lineno () que se encuentra en cool.cup .","title":"3. Salida del Parser"},{"location":"projects/proj02/#4-manejo-de-errores","text":"Ustedes deber\u00edan de utilizar el pseudo no terminal error para manejar errores en el parser. El prop\u00f3sito de error es permitirle al parser continuar despu\u00e9s de un error anticipado. No es un panacea y el parser puede volverse completamente confuso. Vean la documentaci\u00f3n de JCup 2 para saber como utilizar error correctamente. Para recibir toda la nota, su parser deber\u00eda de recuperarse por lo menos en las siguientes situaciones: Si hay alg\u00fan error en una definici\u00f3n de clase pero la clase es terminada correctamente y la siguiente clase est\u00e1 correcta sint\u00e1cticamente, el parser deber\u00eda de ser capaz de empezar de nuevo en la siguiente definici\u00f3n de clase. Similarmente, el parser deber\u00eda de recuperarse de errores en las caracter\u00edsticas (yendo a la siguiente caracter\u00edstica). En un let , yendo a la siguiente variable. En un bloque, yendo a la siguiente expresi\u00f3n. No se preocupen demasiado por los n\u00fameros de l\u00ednea que aparecen en los mensajes de error que su parser genera. Si su parser est\u00e1 funcionando correctamente, el n\u00famero de l\u00ednea generalmente va a ser la l\u00ednea donde se encontr\u00f3 el error. Para constructs erroneos que abarquen m\u00faltiples l\u00edneas, el n\u00famero de l\u00ednea por lo general va a ser la \u00faltima l\u00ednea del construct.","title":"4. Manejo de Errores"},{"location":"projects/proj02/#5-observaciones","text":"Ustedes van a necesitar declaraciones de precedencia, pero solo para las expresiones. No utilicen declaraciones de precedencia ciegamente (es decir, no resuelvan un conflicto shift-reduce en su gram\u00e1tica agregando reglas de precedencia hasta que ya no aparezca). El let de COOL introduce una ambiguedad en el lenguage (traten de construir un ejemplo si es que no est\u00e1n convencidos). El manual resuelve esta ambiguedad diciendo que el let se extiende a la derecha tanto como se pueda. Dependiendo de como su gram\u00e1tica sea escrita, esta ambiguedad puede aparecer en su parser como un conflicto shift-reduce involucrando las producciones del let. Si ustedes se encuentran en esta situaci\u00f3n, talvez quieran considerar resolver el problema utilizando caracter\u00edsticas de JCup que permitan que la precedencia sea asociada a las producciones (no solamente a los operadores). Vean la documentaci\u00f3n de JCup 2 para obtener informaci\u00f3n en como utilizar esta caracter\u00edstica. Dado que el compilador ./mycoolc utiliza pipes para comunicar de una fase a la siguiente, cualquier caracter extra\u00f1o producido por el parser puede causar errores, en particular, el analizador sem\u00e1ntico no pueda analizar el AST que su parser produce. Dado que cualquier print utilizado en su c\u00f3digo puede causar que pierdan errores, por favor aseg\u00farense de remover cualquier print de su c\u00f3digo antes de probar el autograder de esta asignaci\u00f3n.","title":"5. Observaciones"},{"location":"projects/proj02/#6-notas-de-java","text":"Ustedes deber\u00edan de declarar \"tipos\" para sus no terminales y los terminales que tengan valor, por ejemplo, en el archivo cool.cup est\u00e1 la declaraci\u00f3n: 1 nonterminal programc program ; Esta declaraci\u00f3n dice que el no terminal program tiene tipo programc . Es cr\u00edtico que ustedes declaren el tipo correcto para los atributos de los s\u00edmbolos de la gram\u00e1tica, fallar en hacerlo virtualmente hace que su parser no funcione correctamente. Ustedes no necesitan declarar tipos para los s\u00edmbolos de la gram\u00e1tica que no tengan atributos. El chequeo de tipos del compilador de java javac se puede quejar si utilizan los constructores de los nodos del \u00e1rbol con el tipo incorrecto. Si ustedes corrigen los errores con casting, su programa puede lanzar una excepci\u00f3n cuando el constructor note que est\u00e1 siendo utilizado con los tipos incorrectos. Tambi\u00e9n, JCup se puede quejar si crean errores de tipos.","title":"6. Notas de Java"},{"location":"projects/proj02/#7-autograder","text":"Ustedes deber\u00edan de descargar el siguiente script en el mismo directorio donde tienen sus archivos de la segunda fase: 1 2 wget http://raw.githubusercontent.com/CC-4/cc-4.github.io/master/assets/projects/grading/pa2-grading.pl chmod +x pa2-grading.pl y ejecutar el siguiente comando: 1 ./pa2-grading.pl Esto califica su parser utilizando el analizador l\u00e9xico de coolc. Si ustedes quieren probar su parser utilizando la fase 1: 1 2 wget http://raw.githubusercontent.com/CC-4/cc-4.github.io/master/assets/projects/grading/pa2-grading-all.sh chmod +x pa2-grading-all.sh y ejecutar el siguiente comando: 1 ./pa2-grading-all.sh","title":"7. Autograder"},{"location":"projects/proj02/#referencias","text":"The Tree Package - Javadoc del paquete Tree. \u21a9 JCup Manual - Manual de JCup \u21a9 \u21a9 \u21a9 The Cool Reference Manual - Manual de COOL. \u21a9 Tour of the Cool Support Code - Manual del C\u00f3digo de Soporte de COOL. \u21a9 SPIM Manual - Manual de SPIM. \u21a9 JCup Java Manual - Javadoc de JCup \u21a9","title":"Referencias"},{"location":"projects/proj03/","text":"An\u00e1lisis Sem\u00e1ntico \u00b6 En est\u00e1 asignaci\u00f3n, ustedes van a implementar el an\u00e1lisis sem\u00e1ntico para COOL. Ustedes van a utilizar el AST construido por el parser para verificar si el programa est\u00e1 correcto sem\u00e1nticamente siguiendo la especificaci\u00f3n de COOL. Su analizador sem\u00e1ntico deber\u00eda de rechazar programas erroneos; para programas que est\u00e9n correctos, deber\u00eda de reunir informaci\u00f3n que va a ser utilizada por el generador de c\u00f3digo. La salida del analizador sem\u00e1ntico va a ser un AST anotado utilizado por su generador de c\u00f3digo. Esta asignaci\u00f3n tiene m\u00e1s libertad para tomar decisiones de dise\u00f1o que las \u00faltimas dos asignaciones. Su programa va a ser correcto si puede verificar programas reflejando la especificaci\u00f3n. No hay una sola soluci\u00f3n para esta asignaci\u00f3n, pero hay muchas malas maneras de implementarla. Hay un n\u00famero de practicas est\u00e1ndar que creemos que hacen la vida m\u00e1s f\u00e1cil, y los vamos a tratar de inculcar estas pr\u00e1cticas en ustedes. Sin embargo, lo que ustedes hagan es su responsabilidad, cualquier cosa que ustedes decidan hacer, est\u00e9n preparados para justificarla y explicarla. Ustedes van a necesitar referirse a las reglas de inferencia de tipos descritas en el manual de referencia de COOL 2 . Ustedes tambi\u00e9n van a necesitar agregar m\u00e9todos y atributos a los nodos del AST para esta fase. Las funciones que el paquete tree provee est\u00e1n documentadas en el Manual del c\u00f3digo de soporte de COOL 3 . Hay mucha informaci\u00f3n en este documento, y ustedes necesitan saber la mayor\u00eda de esta informaci\u00f3n para crear un analizador sem\u00e1ntico funcional. Por favor lean esta asignaci\u00f3n detenida y cuidadosamente. A alto nivel, su analizador sem\u00e1ntico deber\u00eda de poder lograr las siguientes tareas: Ver todas las clases y construir un grafo de herencia. Verificar que el grafo est\u00e9 bien formado. Para cada clase: Atravesar el AST, reuniendo todas las declaraciones visibles en una tabla de s\u00edmbolos. Verificar que los tipos de cada expresi\u00f3n sean correctos. Anotar el AST con tipos. Esta lista de tareas podr\u00eda no ser exhaustiva, es responsabilidad de ustedes de implementar la especificaci\u00f3n descrita en el manual. 1. Archivos y Directorios \u00b6 Para empezar, creen el directorio PA3 en su carpeta que contendr\u00e1 todas las dem\u00e1s fases como se explic\u00f3 aqu\u00ed y dentro de esa carpeta en una terminal ( CTRL + T ) escriban lo siguiente: 1 make -f /usr/class/cs143/assignments/PA4J/Makefile Este comando va a copiar un n\u00famero de archivos en su directorio que han creado. Algunos de los archivos que van a ser copiados van a ser de solo lectura (representando a estos con archivos que realmente son enlaces simb\u00f3licos hacia otros archivos). Ustedes no deber\u00edan de editar estos archivos. De hecho, si ustedes modifican estos archivos, van a encontrar imposible terminar y completar esta asignaci\u00f3n. Vean las instrucciones en el archivo README. Los \u00fanicos archivos que tienen permitido modificar para esta asignaci\u00f3n son: cool-tree.java : Este archivo contiene definiciones de los nodos del AST y es el archivo principal de su implementaci\u00f3n. Ustedes van a necesitar agregar c\u00f3digo para su analizador sem\u00e1ntico en este archivo. El analizador sem\u00e1ntico es llamado utilizando el m\u00e9todo smenat() de la clase programc . No modifiquen las declaraciones existentes. ClassTable.java : Esta clase es un placeholder para algunos m\u00e9todos \u00fatiles (incluyendo reporte de errores e inicializaci\u00f3n de las clases b\u00e1sicas). Pueden utilizar este archivo y mejorarlo para su analizador sem\u00e1ntico. TreeConstants.java : Este archivo define algunos AbstractSymbol \u00fatiles. good.cl y bad.cl : Estos archivos prueban algunas caracter\u00edsticas sem\u00e1nticas de COOL. Ustedes deber\u00edan de agregar tests que aseguren que good.cl tome en cuenta combinaciones sem\u00e1nticas legales (tantas como se puedan) y en bad.cl lo contrario combinaciones sem\u00e1nticas ilegales. No es posible tomar en cuenta todas estas combinaciones en un solo archivo, ustedes son responsables de cubrir la mayor\u00eda de estas. Expliquen sus pruebas en estos archivos y pongan cualquier comentario en el archivo README. SemantErrors.java : Este archivo contiene m\u00e9todos que generan los errores correspondientes para el an\u00e1lisis sem\u00e1ntico. README : Este archivo contiene instrucciones detalladas para la asignaci\u00f3n, as\u00ed como tambi\u00e9n un n\u00famero de recomendaciones \u00fatiles. En este archivo deber\u00edan de colocar el dise\u00f1o de su implemetanci\u00f3n y porque su soluci\u00f3n es correcta. 2. Atravesar el AST \u00b6 Como resultado de la asignaci\u00f3n 2, su parser construye un AST. El m\u00e9todo dump_with_types , definido en la mayor\u00eda de nodos del AST, ilustra como atravesar el AST y reunir informaci\u00f3n de el. Esto refleja un estilo de algoritmo recursivo para atravesar el \u00e1rbol. Esto es bastante importante, porque es una manera natural de estructurar varios c\u00e1lculos en un AST. Su tarea de programaci\u00f3n en esta asignaci\u00f3n es, primero atravesar el \u00e1rbol, segundo manejar varias piezas de informaci\u00f3n que ustedes reunan del \u00e1rbol y tercero utilizar esa informaci\u00f3n para forzar la sem\u00e1ntica de COOL. Atravesar el \u00e1rbol una vez se le suele llamar una \"pasada\". Ustedes probablemente van a necesitar hacer almenos dos pasadas sobre el AST para verificar todo. Ustedes van a necesitar agregar informaci\u00f3n adicional en los nodos del AST. Para hacer esto, van a necesitar editar el archivo cool-tree.java directamente. 3. Herencia \u00b6 Las relaciones de herencia especifican un grafo dirigido de dependencias de clases. Un requerimiento t\u00edpico de la mayor\u00eda de lenguajes con herencia es que el grafo de herencia no tenga ciclos. Es responsabilidad de ustedes que su analizador sem\u00e1ntico asegure esto. Una manera relativamente f\u00e1cil de hacer esto, es construir una representaci\u00f3n del grafo de tipos y luego verificar los ciclos. \u00bfSe recuerdan de c\u00f3mo representabamos un grafo en CC2 y c\u00f3mo podemos encontrar ciclos? Adicionalmente, COOL tiene restricciones en heredar de las clases b\u00e1sicas (vean el manual 2 ). Es tambi\u00e9n un error si la clase A hereda de la clase B pero la clase B no est\u00e1 definida. El esqueleto del proyecto incluye definiciones apropiadas de todas las clases b\u00e1sicas. Ustedes van a necesitar incorporar estas clases en el grafo de herencia. Les sugerimos que dividan su an\u00e1lisis sem\u00e1ntico en dos peque\u00f1os componentes. Primero, verificar que el grafo de herencia est\u00e9 bien definido, es aceptable abortar la compilaci\u00f3n (despu\u00e9s de imprimir los errores apropiados en consola, \u00a1por supuesto!). Segundo, verificar todas las dem\u00e1s condiciones sem\u00e1nticas. Es m\u00e1s f\u00e1cil de implementar este segundo componente si uno sabe que el grafo de herencia y que este es correcto. 4. Scopes y Variables \u00b6 Una gran porci\u00f3n del an\u00e1lisis sem\u00e1ntico es manejar los nombres de variables. El problema en espec\u00edfico es determinar que declaraci\u00f3n est\u00e1 activa para cada uso de una variable o identificador, especialmente cuando un nombre de variable puede ser reutilizado. Por ejemplo, si i es declarado en dos expresiones let , una anidada dentro de la otra, entonces en cualquier momento que i sea referenciado la sem\u00e1ntica de COOL especifica que declaraci\u00f3n de estas dos est\u00e1 activa. Es trabajo del analizador sem\u00e1ntico guardar un registro de que declaraci\u00f3n hace referencia a una variable. Como se discuti\u00f3 en clase, una tabla de s\u00edmbolos es una estructura de datos conveniente para manejar nombres de variable y scopes. Ustedes pueden utilizar nuestra implementaci\u00f3n de una tabla de s\u00edmbolos para este proyecto. Nuestra implementaci\u00f3n provee m\u00e9todos para entrar, salir y aumentar los scopes como sea posible. Ustedes son libres de implementar su propia tabla de s\u00edmbolos tambi\u00e9n, es como ustedes prefieran. Adem\u00e1s del identificador self , que est\u00e1 implicitamente definido en cada clase, hay cuatro maneras que un objeto pueda ser introducido en COOL: Definiciones de atributos de clase. Par\u00e1metros formales en los m\u00e9todos. Expresiones let. Los branches de un case. Adicionalmente a los nombres de variables, hay nombres de m\u00e9todos y nombres de clases. Es un error utilizar cualquier nombre que no tenga una declaraci\u00f3n correspondiente. En este caso, sin embargo, el analizador sem\u00e1ntico no deber\u00eda de abortar la compilaci\u00f3n despu\u00e9s de descubrir este tipo de errores. Recuerden, ni los m\u00e9todos, ni las clases, ni los atributos necesitan ser declarados antes de ser utilizados, esto es por ejemplo que dentro del m\u00e9todo main se mande a llamar al m\u00e9todo foo y este m\u00e9todo est\u00e9 declarado m\u00e1s abajo en el archivo. Piensen c\u00f3mo esto afecta su an\u00e1lisis sem\u00e1ntico. 5. Verificaci\u00f3n de Tipos \u00b6 La verificaci\u00f3n de tipos es otra funci\u00f3n principal del analizador sem\u00e1ntico. El analizador sem\u00e1ntico tiene que verificar que tipos validos sean declarados en donde sea requerido. Por ejemplo, los tipos de retorno de los m\u00e9todos tienen que ser declarados. Utilizando esta informaci\u00f3n, el analizador sem\u00e1ntico tiene que verificar tambi\u00e9n que la expresi\u00f3n dentro del m\u00e9todo tiene un tipo v\u00e1lido de acuerdo a las reglas de inferencia. Las reglas de inferencia est\u00e1n detalladas en el manual de referencia de COOL 2 y tambi\u00e9n fueron explicadas en clase. Un problema dif\u00edcil es que hacer si una expresi\u00f3n no tiene un tipo valido de acuerdo a las reglas. Primero, un error se deber\u00eda de imprimir con el n\u00famero l\u00ednea y una descripci\u00f3n de que fue lo que estuvo mal. Recomendaci\u00f3n Utilicen la clase de ayuda SemantErrors.java para imprimir los errores necesarios durante el an\u00e1lisis sem\u00e1ntico. Es relativamente f\u00e1cil dar mensajes de error coherentes, porque generalmente es obvio que error es. Nosotros esperamos que ustedes den mensajes de error informativos de acuerdo a lo que se encuentra en SemantErros.java . Segundo, el analizador sem\u00e1ntico tiene que tratar de recuperarse y continuar. Nostros si esperamos que su analizador sem\u00e1ntico se recupere, pero no esperamos que evite errores en cascada. Un mecanismo de recuperaci\u00f3n simple es asignar el tipo Object a cualquier expresi\u00f3n que no se le pueda dar un tipo (nostros utilizamos esto en coolc). 6. Interfaz con CodeGen \u00b6 Para que el analizador sem\u00e1ntico funcione correctamente con el resto del compilador de COOL, algunas precauciones tienen que tomarse en cuenta para que la interfaz con el generador de c\u00f3digo sea correcta. Nostros hemos adoptado una simple e ingenua interfaz para evitar reducir sus impulsos de creatividad en el an\u00e1lisis sem\u00e1ntico. Sin embargo, una cosa m\u00e1s tienen que hacer. Para cada nodo expression, su campo de tipo tiene que ser cambiado al Symbol que fue inferido por su analizador sem\u00e1ntico. Este Symbol deber\u00eda de ser el resultado de utilizar el m\u00e9todo addString en fases anteriores en la tabla idtable . La expresi\u00f3n especial no_expr tiene que ser asignada con el tipo No_type que es un s\u00edmbolo predefinido en el esqueleto del proyecto. 7. Salida Esperada \u00b6 Para programas que esten incorrectos sem\u00e1nticamente, la salida de su analizador sem\u00e1ntico son mensajes de error. Nosotros esperamos de ustedes que se puedan recuperar de la mayor\u00eda de errores exceptuando errores de herencia. Tambi\u00e9n se espera de ustedes que produzcan un mensajes de error informativos de acuerdo a SemantErros.java vean este archivo para imprimir los errores. Asumiendo que la herencia est\u00e1 bien formada, el analizador sem\u00e1ntico deber\u00eda de agarrar y reportar todos los errores sem\u00e1nticos en el programa. Para programas que est\u00e9n correctos sem\u00e1nticamente, la salida es un AST anotado. Ustedes van a ser calificados si su analizador sem\u00e1ntico anota correctamente el AST con tipos y cuando funcione correctamente con el generador de c\u00f3digo de coolc. 8. Probando el Analizador \u00b6 Van a necesitar un analizador l\u00e9xico y sint\u00e1ctico para probar su analizador sem\u00e1ntico. Pueden utilizar sus implementaciones a estas fases o utilizar las que nosotros les proveemos. Por defecto, las que nosotros les proveemos son utilizadas, para cambiar este comportamiento tienen que cambiar los archivos lexer y parser con sus propias implementaciones. De todas maneras el autograder principal de este proyecto utiliza los analizadores del compilador de COOL coolc . Ustedes pueden probar su analizador sem\u00e1ntico utilizando ./mysemant , que es un shell script que \"pega\" el analizador con las fases anteriores. Noten que ./mysemant pueden tomar una bandera -s para depurar el analizador. Utilizar esta bandera hace que la bandera debug se cambie a verdadero, esta est\u00e1 definida en el archivo Flags.java . Agregar el c\u00f3digo que hace la depuraci\u00f3n es su responsabilidad. Vean el README para m\u00e1s detalles. Una vez que est\u00e9n bastante confiados de que su analizador est\u00e1 funcionando correctamente, tratan correr ./mycoolc para invocar su analizador con todas las fases del compilador. Ustedes deber\u00edan de probar este compilador en archivos de entrada buenos y malos, para ver si funciona correctamente. Recuerden, los bugs en el an\u00e1lisis sem\u00e1ntico pueden manifestarse en el c\u00f3digo generado o solo cuando el programa compilado sea ejecutado con spim 4 . 9. Observaciones \u00b6 El an\u00e1lisis sem\u00e1ntico es la fase m\u00e1s larga y compleja hasta el momento del compilador. Nuestra soluci\u00f3n es de aproximadamente 1,300 l\u00edneas de c\u00f3digo bien documentadas en C++. Ustedes van a encontrar esta asignaci\u00f3n f\u00e1cil si se toman un tiempo para dise\u00f1ar el verificador de tipos antes de programar. Preg\u00fantense a ustedes mismos lo siguiente: \u00bfQu\u00e9 requerimientos necesito verificar? \u00bfCu\u00e1ndo necesito verificar un requerimiento? \u00bfCu\u00e1ndo la informaci\u00f3n es requerida para verificar un requerimiento? \u00bfD\u00f3nde est\u00e1 la informaci\u00f3n que necesito para verificar un requerimiento? Si ustedes pueden contestar estas preguntas para cada aspecto de COOL, implementar a soluci\u00f3n deber\u00eda de ser AS EASY AS PIE . 10. Autograder \u00b6 Ustedes deber\u00edan de descargar el siguiente script en el mismo directorio donde tienen sus archivos de la tercera fase: 1 2 wget http://raw.githubusercontent.com/CC-4/cc-4.github.io/master/assets/projects/grading/pa3-grading.pl chmod +x pa3-grading.pl y ejecutar el siguiente comando: 1 ./pa3-grading.pl Esto califica su parser utilizando el analizador l\u00e9xico de coolc. Si ustedes quieren probar su parser utilizando su fase 1 y 2: 1 2 wget http://raw.githubusercontent.com/CC-4/cc-4.github.io/master/assets/projects/grading/pa3-grading-all.sh chmod +x pa3-grading-all.sh y ejecutar el siguiente comando: 1 ./pa3-grading-all.sh Referencias \u00b6 The Tree Package - Javadoc del paquete Tree. \u21a9 The Cool Reference Manual - Manual de COOL. \u21a9 \u21a9 \u21a9 Tour of the Cool Support Code - Manual del C\u00f3digo de Soporte de COOL. \u21a9 SPIM Manual - Manual de SPIM. \u21a9","title":"An\u00e1lisis Sem\u00e1ntico"},{"location":"projects/proj03/#analisis-semantico","text":"En est\u00e1 asignaci\u00f3n, ustedes van a implementar el an\u00e1lisis sem\u00e1ntico para COOL. Ustedes van a utilizar el AST construido por el parser para verificar si el programa est\u00e1 correcto sem\u00e1nticamente siguiendo la especificaci\u00f3n de COOL. Su analizador sem\u00e1ntico deber\u00eda de rechazar programas erroneos; para programas que est\u00e9n correctos, deber\u00eda de reunir informaci\u00f3n que va a ser utilizada por el generador de c\u00f3digo. La salida del analizador sem\u00e1ntico va a ser un AST anotado utilizado por su generador de c\u00f3digo. Esta asignaci\u00f3n tiene m\u00e1s libertad para tomar decisiones de dise\u00f1o que las \u00faltimas dos asignaciones. Su programa va a ser correcto si puede verificar programas reflejando la especificaci\u00f3n. No hay una sola soluci\u00f3n para esta asignaci\u00f3n, pero hay muchas malas maneras de implementarla. Hay un n\u00famero de practicas est\u00e1ndar que creemos que hacen la vida m\u00e1s f\u00e1cil, y los vamos a tratar de inculcar estas pr\u00e1cticas en ustedes. Sin embargo, lo que ustedes hagan es su responsabilidad, cualquier cosa que ustedes decidan hacer, est\u00e9n preparados para justificarla y explicarla. Ustedes van a necesitar referirse a las reglas de inferencia de tipos descritas en el manual de referencia de COOL 2 . Ustedes tambi\u00e9n van a necesitar agregar m\u00e9todos y atributos a los nodos del AST para esta fase. Las funciones que el paquete tree provee est\u00e1n documentadas en el Manual del c\u00f3digo de soporte de COOL 3 . Hay mucha informaci\u00f3n en este documento, y ustedes necesitan saber la mayor\u00eda de esta informaci\u00f3n para crear un analizador sem\u00e1ntico funcional. Por favor lean esta asignaci\u00f3n detenida y cuidadosamente. A alto nivel, su analizador sem\u00e1ntico deber\u00eda de poder lograr las siguientes tareas: Ver todas las clases y construir un grafo de herencia. Verificar que el grafo est\u00e9 bien formado. Para cada clase: Atravesar el AST, reuniendo todas las declaraciones visibles en una tabla de s\u00edmbolos. Verificar que los tipos de cada expresi\u00f3n sean correctos. Anotar el AST con tipos. Esta lista de tareas podr\u00eda no ser exhaustiva, es responsabilidad de ustedes de implementar la especificaci\u00f3n descrita en el manual.","title":"An\u00e1lisis Sem\u00e1ntico"},{"location":"projects/proj03/#1-archivos-y-directorios","text":"Para empezar, creen el directorio PA3 en su carpeta que contendr\u00e1 todas las dem\u00e1s fases como se explic\u00f3 aqu\u00ed y dentro de esa carpeta en una terminal ( CTRL + T ) escriban lo siguiente: 1 make -f /usr/class/cs143/assignments/PA4J/Makefile Este comando va a copiar un n\u00famero de archivos en su directorio que han creado. Algunos de los archivos que van a ser copiados van a ser de solo lectura (representando a estos con archivos que realmente son enlaces simb\u00f3licos hacia otros archivos). Ustedes no deber\u00edan de editar estos archivos. De hecho, si ustedes modifican estos archivos, van a encontrar imposible terminar y completar esta asignaci\u00f3n. Vean las instrucciones en el archivo README. Los \u00fanicos archivos que tienen permitido modificar para esta asignaci\u00f3n son: cool-tree.java : Este archivo contiene definiciones de los nodos del AST y es el archivo principal de su implementaci\u00f3n. Ustedes van a necesitar agregar c\u00f3digo para su analizador sem\u00e1ntico en este archivo. El analizador sem\u00e1ntico es llamado utilizando el m\u00e9todo smenat() de la clase programc . No modifiquen las declaraciones existentes. ClassTable.java : Esta clase es un placeholder para algunos m\u00e9todos \u00fatiles (incluyendo reporte de errores e inicializaci\u00f3n de las clases b\u00e1sicas). Pueden utilizar este archivo y mejorarlo para su analizador sem\u00e1ntico. TreeConstants.java : Este archivo define algunos AbstractSymbol \u00fatiles. good.cl y bad.cl : Estos archivos prueban algunas caracter\u00edsticas sem\u00e1nticas de COOL. Ustedes deber\u00edan de agregar tests que aseguren que good.cl tome en cuenta combinaciones sem\u00e1nticas legales (tantas como se puedan) y en bad.cl lo contrario combinaciones sem\u00e1nticas ilegales. No es posible tomar en cuenta todas estas combinaciones en un solo archivo, ustedes son responsables de cubrir la mayor\u00eda de estas. Expliquen sus pruebas en estos archivos y pongan cualquier comentario en el archivo README. SemantErrors.java : Este archivo contiene m\u00e9todos que generan los errores correspondientes para el an\u00e1lisis sem\u00e1ntico. README : Este archivo contiene instrucciones detalladas para la asignaci\u00f3n, as\u00ed como tambi\u00e9n un n\u00famero de recomendaciones \u00fatiles. En este archivo deber\u00edan de colocar el dise\u00f1o de su implemetanci\u00f3n y porque su soluci\u00f3n es correcta.","title":"1. Archivos y Directorios"},{"location":"projects/proj03/#2-atravesar-el-ast","text":"Como resultado de la asignaci\u00f3n 2, su parser construye un AST. El m\u00e9todo dump_with_types , definido en la mayor\u00eda de nodos del AST, ilustra como atravesar el AST y reunir informaci\u00f3n de el. Esto refleja un estilo de algoritmo recursivo para atravesar el \u00e1rbol. Esto es bastante importante, porque es una manera natural de estructurar varios c\u00e1lculos en un AST. Su tarea de programaci\u00f3n en esta asignaci\u00f3n es, primero atravesar el \u00e1rbol, segundo manejar varias piezas de informaci\u00f3n que ustedes reunan del \u00e1rbol y tercero utilizar esa informaci\u00f3n para forzar la sem\u00e1ntica de COOL. Atravesar el \u00e1rbol una vez se le suele llamar una \"pasada\". Ustedes probablemente van a necesitar hacer almenos dos pasadas sobre el AST para verificar todo. Ustedes van a necesitar agregar informaci\u00f3n adicional en los nodos del AST. Para hacer esto, van a necesitar editar el archivo cool-tree.java directamente.","title":"2. Atravesar el AST"},{"location":"projects/proj03/#3-herencia","text":"Las relaciones de herencia especifican un grafo dirigido de dependencias de clases. Un requerimiento t\u00edpico de la mayor\u00eda de lenguajes con herencia es que el grafo de herencia no tenga ciclos. Es responsabilidad de ustedes que su analizador sem\u00e1ntico asegure esto. Una manera relativamente f\u00e1cil de hacer esto, es construir una representaci\u00f3n del grafo de tipos y luego verificar los ciclos. \u00bfSe recuerdan de c\u00f3mo representabamos un grafo en CC2 y c\u00f3mo podemos encontrar ciclos? Adicionalmente, COOL tiene restricciones en heredar de las clases b\u00e1sicas (vean el manual 2 ). Es tambi\u00e9n un error si la clase A hereda de la clase B pero la clase B no est\u00e1 definida. El esqueleto del proyecto incluye definiciones apropiadas de todas las clases b\u00e1sicas. Ustedes van a necesitar incorporar estas clases en el grafo de herencia. Les sugerimos que dividan su an\u00e1lisis sem\u00e1ntico en dos peque\u00f1os componentes. Primero, verificar que el grafo de herencia est\u00e9 bien definido, es aceptable abortar la compilaci\u00f3n (despu\u00e9s de imprimir los errores apropiados en consola, \u00a1por supuesto!). Segundo, verificar todas las dem\u00e1s condiciones sem\u00e1nticas. Es m\u00e1s f\u00e1cil de implementar este segundo componente si uno sabe que el grafo de herencia y que este es correcto.","title":"3. Herencia"},{"location":"projects/proj03/#4-scopes-y-variables","text":"Una gran porci\u00f3n del an\u00e1lisis sem\u00e1ntico es manejar los nombres de variables. El problema en espec\u00edfico es determinar que declaraci\u00f3n est\u00e1 activa para cada uso de una variable o identificador, especialmente cuando un nombre de variable puede ser reutilizado. Por ejemplo, si i es declarado en dos expresiones let , una anidada dentro de la otra, entonces en cualquier momento que i sea referenciado la sem\u00e1ntica de COOL especifica que declaraci\u00f3n de estas dos est\u00e1 activa. Es trabajo del analizador sem\u00e1ntico guardar un registro de que declaraci\u00f3n hace referencia a una variable. Como se discuti\u00f3 en clase, una tabla de s\u00edmbolos es una estructura de datos conveniente para manejar nombres de variable y scopes. Ustedes pueden utilizar nuestra implementaci\u00f3n de una tabla de s\u00edmbolos para este proyecto. Nuestra implementaci\u00f3n provee m\u00e9todos para entrar, salir y aumentar los scopes como sea posible. Ustedes son libres de implementar su propia tabla de s\u00edmbolos tambi\u00e9n, es como ustedes prefieran. Adem\u00e1s del identificador self , que est\u00e1 implicitamente definido en cada clase, hay cuatro maneras que un objeto pueda ser introducido en COOL: Definiciones de atributos de clase. Par\u00e1metros formales en los m\u00e9todos. Expresiones let. Los branches de un case. Adicionalmente a los nombres de variables, hay nombres de m\u00e9todos y nombres de clases. Es un error utilizar cualquier nombre que no tenga una declaraci\u00f3n correspondiente. En este caso, sin embargo, el analizador sem\u00e1ntico no deber\u00eda de abortar la compilaci\u00f3n despu\u00e9s de descubrir este tipo de errores. Recuerden, ni los m\u00e9todos, ni las clases, ni los atributos necesitan ser declarados antes de ser utilizados, esto es por ejemplo que dentro del m\u00e9todo main se mande a llamar al m\u00e9todo foo y este m\u00e9todo est\u00e9 declarado m\u00e1s abajo en el archivo. Piensen c\u00f3mo esto afecta su an\u00e1lisis sem\u00e1ntico.","title":"4. Scopes y Variables"},{"location":"projects/proj03/#5-verificacion-de-tipos","text":"La verificaci\u00f3n de tipos es otra funci\u00f3n principal del analizador sem\u00e1ntico. El analizador sem\u00e1ntico tiene que verificar que tipos validos sean declarados en donde sea requerido. Por ejemplo, los tipos de retorno de los m\u00e9todos tienen que ser declarados. Utilizando esta informaci\u00f3n, el analizador sem\u00e1ntico tiene que verificar tambi\u00e9n que la expresi\u00f3n dentro del m\u00e9todo tiene un tipo v\u00e1lido de acuerdo a las reglas de inferencia. Las reglas de inferencia est\u00e1n detalladas en el manual de referencia de COOL 2 y tambi\u00e9n fueron explicadas en clase. Un problema dif\u00edcil es que hacer si una expresi\u00f3n no tiene un tipo valido de acuerdo a las reglas. Primero, un error se deber\u00eda de imprimir con el n\u00famero l\u00ednea y una descripci\u00f3n de que fue lo que estuvo mal. Recomendaci\u00f3n Utilicen la clase de ayuda SemantErrors.java para imprimir los errores necesarios durante el an\u00e1lisis sem\u00e1ntico. Es relativamente f\u00e1cil dar mensajes de error coherentes, porque generalmente es obvio que error es. Nosotros esperamos que ustedes den mensajes de error informativos de acuerdo a lo que se encuentra en SemantErros.java . Segundo, el analizador sem\u00e1ntico tiene que tratar de recuperarse y continuar. Nostros si esperamos que su analizador sem\u00e1ntico se recupere, pero no esperamos que evite errores en cascada. Un mecanismo de recuperaci\u00f3n simple es asignar el tipo Object a cualquier expresi\u00f3n que no se le pueda dar un tipo (nostros utilizamos esto en coolc).","title":"5. Verificaci\u00f3n de Tipos"},{"location":"projects/proj03/#6-interfaz-con-codegen","text":"Para que el analizador sem\u00e1ntico funcione correctamente con el resto del compilador de COOL, algunas precauciones tienen que tomarse en cuenta para que la interfaz con el generador de c\u00f3digo sea correcta. Nostros hemos adoptado una simple e ingenua interfaz para evitar reducir sus impulsos de creatividad en el an\u00e1lisis sem\u00e1ntico. Sin embargo, una cosa m\u00e1s tienen que hacer. Para cada nodo expression, su campo de tipo tiene que ser cambiado al Symbol que fue inferido por su analizador sem\u00e1ntico. Este Symbol deber\u00eda de ser el resultado de utilizar el m\u00e9todo addString en fases anteriores en la tabla idtable . La expresi\u00f3n especial no_expr tiene que ser asignada con el tipo No_type que es un s\u00edmbolo predefinido en el esqueleto del proyecto.","title":"6. Interfaz con CodeGen"},{"location":"projects/proj03/#7-salida-esperada","text":"Para programas que esten incorrectos sem\u00e1nticamente, la salida de su analizador sem\u00e1ntico son mensajes de error. Nosotros esperamos de ustedes que se puedan recuperar de la mayor\u00eda de errores exceptuando errores de herencia. Tambi\u00e9n se espera de ustedes que produzcan un mensajes de error informativos de acuerdo a SemantErros.java vean este archivo para imprimir los errores. Asumiendo que la herencia est\u00e1 bien formada, el analizador sem\u00e1ntico deber\u00eda de agarrar y reportar todos los errores sem\u00e1nticos en el programa. Para programas que est\u00e9n correctos sem\u00e1nticamente, la salida es un AST anotado. Ustedes van a ser calificados si su analizador sem\u00e1ntico anota correctamente el AST con tipos y cuando funcione correctamente con el generador de c\u00f3digo de coolc.","title":"7. Salida Esperada"},{"location":"projects/proj03/#8-probando-el-analizador","text":"Van a necesitar un analizador l\u00e9xico y sint\u00e1ctico para probar su analizador sem\u00e1ntico. Pueden utilizar sus implementaciones a estas fases o utilizar las que nosotros les proveemos. Por defecto, las que nosotros les proveemos son utilizadas, para cambiar este comportamiento tienen que cambiar los archivos lexer y parser con sus propias implementaciones. De todas maneras el autograder principal de este proyecto utiliza los analizadores del compilador de COOL coolc . Ustedes pueden probar su analizador sem\u00e1ntico utilizando ./mysemant , que es un shell script que \"pega\" el analizador con las fases anteriores. Noten que ./mysemant pueden tomar una bandera -s para depurar el analizador. Utilizar esta bandera hace que la bandera debug se cambie a verdadero, esta est\u00e1 definida en el archivo Flags.java . Agregar el c\u00f3digo que hace la depuraci\u00f3n es su responsabilidad. Vean el README para m\u00e1s detalles. Una vez que est\u00e9n bastante confiados de que su analizador est\u00e1 funcionando correctamente, tratan correr ./mycoolc para invocar su analizador con todas las fases del compilador. Ustedes deber\u00edan de probar este compilador en archivos de entrada buenos y malos, para ver si funciona correctamente. Recuerden, los bugs en el an\u00e1lisis sem\u00e1ntico pueden manifestarse en el c\u00f3digo generado o solo cuando el programa compilado sea ejecutado con spim 4 .","title":"8. Probando el Analizador"},{"location":"projects/proj03/#9-observaciones","text":"El an\u00e1lisis sem\u00e1ntico es la fase m\u00e1s larga y compleja hasta el momento del compilador. Nuestra soluci\u00f3n es de aproximadamente 1,300 l\u00edneas de c\u00f3digo bien documentadas en C++. Ustedes van a encontrar esta asignaci\u00f3n f\u00e1cil si se toman un tiempo para dise\u00f1ar el verificador de tipos antes de programar. Preg\u00fantense a ustedes mismos lo siguiente: \u00bfQu\u00e9 requerimientos necesito verificar? \u00bfCu\u00e1ndo necesito verificar un requerimiento? \u00bfCu\u00e1ndo la informaci\u00f3n es requerida para verificar un requerimiento? \u00bfD\u00f3nde est\u00e1 la informaci\u00f3n que necesito para verificar un requerimiento? Si ustedes pueden contestar estas preguntas para cada aspecto de COOL, implementar a soluci\u00f3n deber\u00eda de ser AS EASY AS PIE .","title":"9. Observaciones"},{"location":"projects/proj03/#10-autograder","text":"Ustedes deber\u00edan de descargar el siguiente script en el mismo directorio donde tienen sus archivos de la tercera fase: 1 2 wget http://raw.githubusercontent.com/CC-4/cc-4.github.io/master/assets/projects/grading/pa3-grading.pl chmod +x pa3-grading.pl y ejecutar el siguiente comando: 1 ./pa3-grading.pl Esto califica su parser utilizando el analizador l\u00e9xico de coolc. Si ustedes quieren probar su parser utilizando su fase 1 y 2: 1 2 wget http://raw.githubusercontent.com/CC-4/cc-4.github.io/master/assets/projects/grading/pa3-grading-all.sh chmod +x pa3-grading-all.sh y ejecutar el siguiente comando: 1 ./pa3-grading-all.sh","title":"10. Autograder"},{"location":"projects/proj03/#referencias","text":"The Tree Package - Javadoc del paquete Tree. \u21a9 The Cool Reference Manual - Manual de COOL. \u21a9 \u21a9 \u21a9 Tour of the Cool Support Code - Manual del C\u00f3digo de Soporte de COOL. \u21a9 SPIM Manual - Manual de SPIM. \u21a9","title":"Referencias"}]}